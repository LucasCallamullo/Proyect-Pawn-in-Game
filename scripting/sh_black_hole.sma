//Black Hole! Spawn a black hole that sucks up ur enemies(if u get sucked in u implode causin damage to allies)

/* CVARS - copy and paste to shconfig.cfg

//Black Hole
black_level 10
black_time 15    //amnt of time the black hole stays after spawned
black_cooldown 30  //amnt of time before they can use again
black_range 1000 //how how far can ppl be before it starts pullin em in
black_force 800 //how strong it is
black_adminflag o //go on guess what this does
black_thinktime 2 //how long victims get to pray to their god

*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <amxmod>
#include <Vexd_Utilities>
#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Black Hole"
new bool:gHasBHPower[SH_MAXSLOTS+1]
new bool:gHasBHSelected[SH_MAXSLOTS+1]
new ppl[SH_MAXSLOTS], pnum

new gBHTimer, gCurrentBH, gRange, gForce
new pcvarRange, pcvarForce, pcvarTimer, pcvarCooldown, pcvarKill, pcvarAdmin
new g_lastPosition[SH_MAXSLOTS+1][3]

#if SEND_COOLDOWN
	new Float:BHUsedTime[SH_MAXSLOTS+1]
#endif
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Black Hole", "1.0", "Random1")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvar_lev 	= register_cvar("black_level", "9")
	pcvarTimer 	= register_cvar("black_time", "15")
	pcvarCooldown 	= register_cvar("black_cooldown", "30")
	pcvarRange 	= register_cvar("black_range", "1000")
	pcvarForce	= register_cvar("black_force", "800")
	pcvarKill	= register_cvar("black_thinktime", "2")		// tiempo para llegar a matar a alguien
	pcvarAdmin	= register_cvar("black_adminflag", "p")
	
	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvar_lev);
	sh_set_hero_info(gHeroID, "Crea un Agujero Negro! (Only Admin!)", "Creas un agujero negro en el mapa que atrae con fuerzas a tus enemigos y aliados!");
	sh_set_hero_bind(gHeroID); 
	
	// LOOP
	set_task(2.0, "black_loop", 0, "", 0, "b")
}

public plugin_precache()
	precache_model("models/shmod/blackhole.mdl")
//------------------------------------------------------------------------------------------------
//				SH INIT and KEY							//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode)
	{
		case SH_HERO_ADD: {
			gBHTimer = -1
			gHasBHPower[id] = true
			gPlayerInCooldown[id] = false
			gHasBHSelected[id] = gHasBHPower[id]
			black_admincheck(id) 
		}
		case SH_HERO_DROP: {
			gHasBHPower[id] = false;
			
			if ( gBHTimer >= 0 ) {
				black_endmode(id)
			}
		}
	}
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasBHPower[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] || gBHTimer > 0 ) {
			playSoundDenySelect(id)
			return;
		}
		
		if( gCurrentBH ) {
			sh_chat_message(id, gHeroID, "Hay otro agujero negro espera a que termine, para crear otro." )
			playSoundDenySelect(id)
			return;	
		}
		
		black_create(id)
		positionChangeTimer(id)
		gRange = get_pcvar_num(pcvarRange)
		gForce = get_pcvar_num(pcvarForce)
		gBHTimer = get_pcvar_num(pcvarTimer)
		
		new black_hole = FindEntity(-1, "black_hole")
		gCurrentBH = black_hole
		
		new Float:seconds = get_pcvar_float(pcvarCooldown)
		if ( seconds > 0.0 ) {
			sh_set_cooldown(id, seconds)
			#if SEND_COOLDOWN
				BHUsedTime[id] = get_gametime()
			#endif
		}
	}
}
#if SEND_COOLDOWN
public sendBHCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(pcvarCooldown) - get_gametime() + BHUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//------------------------------------------------------------------------------------------------
//				Black Create and Damage						//
//------------------------------------------------------------------------------------------------
public black_create(id)	
{	 
	new Float:vAim[3], Float:vOrigin[3]
	entity_get_vector(id, EV_VEC_origin, vOrigin)
	VelocityByAim(id, random_num(2, 4), vAim)
	
	vOrigin[0] += vAim[0] + 10
	vOrigin[1] += vAim[1] + 10
	vOrigin[2] += 30.0
	
	new black_hole = create_entity("info_target")
	entity_set_string(black_hole, EV_SZ_classname, "black_hole")
	entity_set_model(black_hole, "models/shmod/blackhole.mdl")	
	entity_set_size(black_hole, Float:{-1.5, -1.5, -0.5}, Float:{1.5, 1.5, 0.5})
	entity_set_int(black_hole, EV_INT_solid, 2)
	entity_set_int(black_hole, EV_INT_movetype, MOVETYPE_FLY)	// aca iba MOVETYPE_TOSS
	entity_set_vector(black_hole, EV_VEC_origin, vOrigin)
	new blackowner = id
	entity_set_edict(black_hole, EV_ENT_owner, blackowner)	//crear dueño de la entidad
	 
	new origin[3]
	get_user_origin(id, origin)
	origin[0]+=50
	set_user_origin(id, origin)	
}
//------------------------------------------------------------------------------------------------
public black_loop()
{
	if ( !shModActive() || !gCurrentBH ) return

	if( gBHTimer < 1) {
		gCurrentBH = 0
		gBHTimer = 0
		new black_hole = FindEntity(-1, "black_hole")
		if (is_valid_ent(black_hole)){
			remove_entity(black_hole)
		}
		return
	}

	gBHTimer--

	new Float:fl_Origin[3]
	entity_get_vector(gCurrentBH, EV_VEC_origin, fl_Origin)
	
	// Do player physics	
	get_players(ppl, pnum, "a")
	for (new i = 0; i < pnum; i++) {
		if(ppl[i] == gCurrentBH) continue

		if(get_entity_distance(ppl[i], gCurrentBH) > gRange ) 	
			continue
			
		new black_hole = FindEntity(-1, "black_hole")
		if( !is_valid_ent(black_hole) ) {
			gCurrentBH = 0
			gBHTimer = 0
		}
		
		SuckPlayerIntoBH(ppl[i], fl_Origin)
	}
}
//-------------------------------------------------------------------------------------------------
SuckPlayerIntoBH(id, Float:fl_Eye[3])
{
	if ( gHasBHPower[id] ) return
	
	new Float:fl_Player[3], Float:fl_Target[3], Float:fl_Velocity[3], Float:fl_Distance
	entity_get_vector(id, EV_VEC_origin, fl_Player)
	
	fl_Target[0] = fl_Eye[0]
	fl_Target[1] = fl_Eye[1]
	fl_Target[2] = fl_Eye[2]
	//fl_Target[2] = 90.0

	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Target[0] += fl_Velocity[1]
	fl_Target[1] -= fl_Velocity[0]
	fl_Target[2] += fl_Velocity[2]

	// Recalculate our direction and set our velocity
	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Velocity[0] = fl_Velocity[0] * gForce
	fl_Velocity[1] = fl_Velocity[1] * gForce
	fl_Velocity[2] = fl_Velocity[2] * gForce
	
	entity_set_vector(id, EV_VEC_velocity, fl_Velocity)
}
//-------------------------------------------------------------------------------------------------
public black_endmode(id)
{
	if ( !is_user_connected(id) ) return

	gBHTimer = -1
	gCurrentBH = 0

	new black_hole = FindEntity(-1, "black_hole")
	if ( is_valid_ent(black_hole) ) {
		remove_entity(black_hole)
	}
}
//-------------------------------------------------------------------------------------------------
public pfn_touch(ptr, ptd) 
{
	if(!is_valid_ent(ptd) || !is_valid_ent(ptr)) return PLUGIN_CONTINUE
	if(!is_user_connected(ptd) || !is_user_alive(ptd)) return PLUGIN_CONTINUE
			
	new classname[32]
	entity_get_string(ptr, EV_SZ_classname, classname, 31)
	if(equal(classname, "black_hole")) {
		new iOwner;
		iOwner = entity_get_edict(ptr, EV_ENT_owner);

		if( is_user_connected(iOwner) && get_user_team(iOwner) != get_user_team(ptd) ) {
			new parm[2]
			parm[0] = ptd
			parm[1] = iOwner 
			Teleport(parm)
		}
	}
	
	return PLUGIN_CONTINUE
} 
//---------------------------------------------------------------------------------------------- 
public Teleport(parm[])
{
	new victim = parm[0]
	new attacker = parm[1]
	
	new origin[3]
	get_user_origin(victim, origin)
	origin[2]-=3000
	set_user_origin(victim, origin) 
	get_user_origin(victim, g_lastPosition[victim]) 
	
	sh_chat_message(victim, gHeroID, "Fuiste abducido por el Agujero Negro.")
		
	new parm[2]
	parm[0] = victim
	parm[1] = attacker 
	set_task(get_pcvar_float(pcvarKill), "remove_player", 0, parm, 2)
}
//---------------------------------------------------------------------------------------------------
public remove_player(parm[])
{
	new victim = parm[0]
	new attacker = parm[1]
	sh_chat_message(victim, gHeroID, "Espero que tu vida haya pasado ante tus ojos, porque es hora de morir.")
	// user_kill(id)
	if ( get_user_team(attacker) != get_user_team(victim) ) {
		
		new damage = read_data(2)
		sh_extra_damage(victim, attacker, damage, "Abducido por Agujero Negro", _, SH_DMG_KILL) 
		
		if ( is_user_alive(victim) )
			positionChangeTimer(victim)
	}
}
//----------------------------------------------------------------------------------------------
public positionChangeTimer(id)
{
	if ( !is_user_alive(id) ) return

	get_user_origin(id, g_lastPosition[id])

	new Float:velocity[3]
	Entvars_Get_Vector(id, EV_VEC_velocity, velocity)

	if ( velocity[0]==0.0 && velocity[1]==0.0 ) {
		// Force a Move (small jump)
		velocity[0] += 20.0
		velocity[2] += 100.0
		Entvars_Set_Vector(id, EV_VEC_velocity, velocity)
	}

	set_task(0.4, "positionChangeCheck", id)
}
//----------------------------------------------------------------------------------------------
public positionChangeCheck(id)
{
	if ( !is_user_alive(id) ) return

	new origin[3]
	get_user_origin(id, origin)
	origin[0]-=60

	if ( g_lastPosition[id][0] == origin[0] && g_lastPosition[id][1] == origin[1] && g_lastPosition[id][2] == origin[2] && is_user_alive(id) ) {
		sh_chat_message(id, gHeroID, "Te las arreglaste para quedarte atrapado en una pared, disculpa evita las paredes la proxima vez.")
		user_kill(id)				
	}
}
//---------------------------------------------------------------------------------------------------
//				Spawn / Admincheck
//---------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	gPlayerUltimateUsed[id] = false
	gBHTimer = -1
	gCurrentBH = 0
	black_endmode(id)
}

public black_admincheck(id) 
{
   	new accessLevel[10] 
	get_pcvar_string(pcvarAdmin, accessLevel, 9)
   	
	if ( gHasBHSelected[id] && !(get_user_flags(id)&read_flags(accessLevel)) ) {
		sh_chat_message(id, gHeroID, "[Only Admin] Conseguite Admin Rata.")
      		gHasBHPower[id] = false
      		client_cmd(id, "say drop %s", gHeroName)
   	}
} 
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
