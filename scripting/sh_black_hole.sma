//Black Hole! Spawn a black hole that sucks up ur enemies(if u get sucked in u implode causin damage to allies)

/* CVARS - copy and paste to shconfig.cfg

//Black Hole
black_level 10
black_time 15   	 //amnt of time the black hole stays after spawned
black_cooldown 30 	 //amnt of time before they can use again
black_range 1000 	//how how far can ppl be before it starts pullin em in
black_force 800 	//how strong it is
black_adminflag o 	//go on guess what this does

*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Black Hole"
new bool:gHasBHPower[SH_MAXSLOTS+1]

// originals and comun pcvar best coding practice
new ppl[SH_MAXSLOTS], pnum, gRange, gForce
new gBHTimer[SH_MAXSLOTS+1], gCurrentBH[SH_MAXSLOTS+1]
new pcvarRange, pcvarForce, pcvarTimer, pcvarCooldown, pcvarAdmin

// This is for cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1] 

// models n name entity
new const gBlackHoleModel[] = "models/shmod/blackhole.mdl"
new const gBlackHole_EntName[] = "black_hole"

// i go to proof this from correct work
new gIsInBlackhole[SH_MAXSLOTS+1]
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Black Hole", "1.0", "Random1")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvar_lev 	= register_cvar("black_level", "9")
	pcvarAdmin	= register_cvar("black_adminflag", "p")
	pcvarCooldown 	= register_cvar("black_cooldown", "30")
	pcvarRange 	= register_cvar("black_range", "1000")
	pcvarForce	= register_cvar("black_force", "800")
	pcvarTimer 	= register_cvar("black_time", "15")
	
	
	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvar_lev);
	sh_set_hero_info(gHeroID, "Crea un Agujero Negro! (Only Admin!)", "Creas un agujero negro en el mapa que atrae con fuerzas a tus enemigos y aliados!");
	sh_set_hero_bind(gHeroID); 
	
	// LOOP
	set_task(1.0, "black_loop", 0, "", 0, "b")
	
	// REGISTERS A TOUCH EVENT, WHEN TWO THINGS TOUCH
	register_touch(gBlackHole_EntName, "player","black_touch")
}

public plugin_precache() precache_model(gBlackHoleModel)
//------------------------------------------------------------------------------------------------
//				SH INIT and KEY							//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
	
	switch(mode) {
		case SH_HERO_ADD: {
			gHasBHPower[id] = true
			gPlayerInCooldown[id] = false
			black_admincheck(id) 
		} 
		case SH_HERO_DROP: {
			gHasBHPower[id] = false;
			if ( gBHTimer[id] >= 0 ) remove_all_bh(id)
		}
	}
	
	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasBHPower[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if( gPlayerInCooldown[id] ) { 
			sh_sound_deny(id) ;
			return;
		}
		
		remove_all_bh(id)	// for delete the owner blackhole if has other before
		black_create(id)	// for create a new black hole
		
		// i think this two is for a better use of memory
		gRange = get_pcvar_num(pcvarRange)
		gForce = get_pcvar_num(pcvarForce)
		gBHTimer[id] = get_pcvar_num(pcvarTimer)

		new Float:seconds = get_pcvar_float(pcvarCooldown)
		if ( seconds > 0.0 ) {
			sh_set_cooldown(id, seconds)
			gPcvarRealCD[id] = seconds
		} 
	}
}
#if SEND_COOLDOWN
public sendBHCooldown(id) {
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id])
}
#endif
//------------------------------------------------------------------------------------------------
//				Loop n Effects from Blackhole
//-------------------------------------------------------------------------------------------------
public black_loop()
{
	for ( new id = 1; id <= SH_MAXSLOTS; id++ ) {
		if ( !gHasBHPower[id] || gCurrentBH[id] == 0 ) continue // return
		
		if ( gBHTimer[id] > 0 ) {
			gBHTimer[id]--		// to reduce de timer 
		} else {
			remove_all_bh(id)
			gBHTimer[id] = -1
			gCurrentBH[id] = 0
			return 
		}
		
		// para buscar la entidad al parecer xD
		new ent = 0;
		while((ent = find_ent_by_class(ent, gBlackHole_EntName)) > 0) {
			if( pev(ent, pev_owner) == id && ent > 0 ) {
				gCurrentBH[id] = ent
				break;
			}
		}
		
		// para evitar spam de bugs de la entidad buscada
		if ( !pev_valid(gCurrentBH[id]) ) return
		
		new Float:fl_Origin[3]
		entity_get_vector(gCurrentBH[id], EV_VEC_origin, fl_Origin)

		// Do player physics	
		get_players(ppl, pnum, "a")
		for (new i = 0; i < pnum; i++) {
			// if( ppl[i] == gCurrentBH[id] ) continue
			if( ppl[i] == entity_get_edict(gCurrentBH[id], EV_ENT_owner) ) continue
	  
			if( get_entity_distance(ppl[i], gCurrentBH[id]) > gRange ) continue
				
			SuckPlayerIntoBH(ppl[i], fl_Origin)
		}
	}
}

SuckPlayerIntoBH(id, Float:fl_Eye[3])
{
	new Float:fl_Player[3], Float:fl_Target[3], Float:fl_Velocity[3], Float:fl_Distance
	entity_get_vector(id, EV_VEC_origin, fl_Player)
	
	fl_Target[0] = fl_Eye[0]
	fl_Target[1] = fl_Eye[1]
	fl_Target[2] = fl_Eye[2]
	//fl_Target[2] = 90.0

	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Target[0] += fl_Velocity[1]
	fl_Target[1] -= fl_Velocity[0]
	fl_Target[2] += fl_Velocity[2]

	// Recalculate our direction and set our velocity
	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Velocity[0] = fl_Velocity[0] * gForce
	fl_Velocity[1] = fl_Velocity[1] * gForce
	fl_Velocity[2] = fl_Velocity[2] * gForce
	
	entity_set_vector(id, EV_VEC_velocity, fl_Velocity)
}

public black_touch(ent, id) 
{
	// if (!is_valid_ent(id) || !is_valid_ent(ent)) return
	if ( !pev_valid(ent) || !pev_valid(id) ) return
		
	new classname[32]
	entity_get_string(ent, EV_SZ_classname, classname, 31)
	if(equal(classname, gBlackHole_EntName)) { 
		static iOwner; iOwner = entity_get_edict(ent, EV_ENT_owner); 
		// static iOwner; iOwner = pev(ent, pev_owner) 
		   
		new players[SH_MAXSLOTS], pnum, vic
		get_players(players, pnum, "a")
		for (new i = 0; i < pnum; i++) {
			vic = players[i]

			if ( !is_user_alive(vic) ) continue
			// && iOwner != vic 
			if ( get_user_team(iOwner) == get_user_team(vic) ) continue // && !get_cvar_num("mp_friendlyfire")
	
			bh_effect_stun(vic, iOwner)	
		}
	}
} 

public bh_effect_stun(victim, iOwner)
{
	if ( !is_user_alive(victim) || get_user_team(iOwner) == get_user_team(victim) ) return
	 
	if ( !gIsInBlackhole[victim] ) { 
		sh_chat_message(victim, gHeroID, "Fuiste abducido por %s.", gHeroName)
		sh_set_stun(victim, 2.0, 100.0)
		gIsInBlackhole[victim] = true
	} else {
		set_task(1.5, "unset_stun_bh", victim)
	}
	// sh_add_hp(victim, 40)	// This is for prevent the kill with the entity
}

public unset_stun_bh(victim) {
	gIsInBlackhole[victim] = false
}
//------------------------------------------------------------------------------------------------
//				Black Create and Remove						//
//------------------------------------------------------------------------------------------------
public black_create(id)	
{	 
	new Float:vAim[3], Float:vOrigin[3]
	entity_get_vector(id, EV_VEC_origin, vOrigin) 
	VelocityByAim(id, random_num(2, 4), vAim)
	
	vOrigin[0] += vAim[0] + 10
	vOrigin[1] += vAim[1] + 10
	vOrigin[2] += 30.0
	
	new black_hole = create_entity("info_target")
	entity_set_string(black_hole, EV_SZ_classname, gBlackHole_EntName) 
	entity_set_model(black_hole, gBlackHoleModel)	
	entity_set_size(black_hole, Float:{-8, -8, -8}, Float:{8, 8, 8})
	entity_set_int(black_hole, EV_INT_solid, 2)
	entity_set_int(black_hole, EV_INT_movetype, MOVETYPE_FLY)	// aca iba MOVETYPE_TOSS
	entity_set_vector(black_hole, EV_VEC_origin, vOrigin)
	entity_set_edict(black_hole, EV_ENT_owner, id)	//crear dueño de la entidad
	
	gCurrentBH[id] = black_hole;
}

public remove_all_bh(id)
{
	new ent = 33;
	while((ent = find_ent_by_class(ent, gBlackHole_EntName)) != 0) {
		// if( entity_get_edict(ent, EV_ENT_owner) != id ) continue;
		if( pev(ent, pev_owner) != id ) continue;
			 
		// set_pev(ent, pev_flags, FL_KILLME)
		remove_entity(ent);
		// set_pev(ent, pev_nextthink, get_gametime() + 0.1);
	}
}
//------------------------------------------------------------------------------------------------
//				Disconected and Round New					//
//------------------------------------------------------------------------------------------------ 
public client_disconnected(id)
{
	if(gHasBHPower[id] && gBHTimer[id] >= 0)
		if ( pev_valid(gCurrentBH[id]) ) 
			remove_all_bh(id)
}

public sh_round_end() {
	for (new id=1; id <= SH_MAXSLOTS; id++) 
		if( gHasBHPower[id] ) remove_all_bh(id)
}
//------------------------------------------------------------------------------------------------
//				Spawn n Death n Admincheck					//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	unset_stun_bh(id)	// para poner en false que pueda stunearse
	
	if (gHasBHPower[id]) {
		black_admincheck(id)

		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	}
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if (gHasBHPower[id]) gPcvarRealCD[id] = sh_get_cooldown(id)
}

public black_admincheck(id) 
{
	if ( !gHasBHPower[id] ) return
	
   	new accessLevel[10]
	get_pcvar_string(pcvarAdmin, accessLevel, 9)
	
	if (equali(accessLevel, "0")) return 
   	
	// Para controlar si tiene admin
	if ( !(get_user_flags(id)&read_flags(accessLevel)) ) {
		sh_chat_message(id, gHeroID, "[Only Admin] Conseguite Admin Rata.")
      		client_cmd(id, "say drop %s", gHeroName)
		gHasBHPower[id] = false
   	}
}


/* another form to do it black_create(id)

	new Float:vOrigin[3]
	pev(id, pev_origin, vOrigin);

	//This will make it so that the disk appears in front of the user
	new Float:viewing_angles[3]
	new distance_from_user = 70
	pev(id, pev_angles, viewing_angles)
	vOrigin[0] += floatcos(viewing_angles[1], degrees) * distance_from_user
	vOrigin[1] += floatsin(viewing_angles[1], degrees) * distance_from_user
	vOrigin[2] += floatsin(-viewing_angles[0], degrees) * distance_from_user
	 
	// This is for create the entity
	new black_hole = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"));
	if (!pev_valid(black_hole)) {
		sh_chat_message(id, gHeroID, "Error al crear el agujero negro.");
		return;
	}

	//sets the classname of the entity
	set_pev(black_hole, pev_classname, gBlackHole_EntName); 
	gCurrentBH[id] = black_hole;
	
	//This tells what the object will look like
	engfunc(EngFunc_SetModel, black_hole, gBlackHoleModel); 

	//This will set the origin of the entity 
	engfunc(EngFunc_SetOrigin, black_hole, vOrigin); 
	
	//This will get the velocity of the entity 
	new Float:vAim[3]
	velocity_by_aim(id, random_num(2, 4), vAim);
	
	//Sets the size of the entity
	new Float: minBound[3] = {-2.5, -2.5, -2.5};  //sets the minimum bound of entity
	new Float: maxBound[3] = {2.5, 2.5, 2.5};    //sets the maximum bound of entity
	set_pev(black_hole, pev_mins, minBound);
	set_pev(black_hole, pev_maxs, maxBound);
	
	engfunc(EngFunc_SetSize, black_hole, minBound, maxBound)

	
	//Sets who the owner of the entity is
	set_pev(black_hole, pev_owner, id);
	
	//This will set the movetype of the entity 
	set_pev(black_hole, pev_movetype, MOVETYPE_FLY); 

	//This makes the entity touchable
	set_pev(black_hole, pev_solid, SOLID_BBOX);
	
	//Sets who the owner of the entity is
	set_pev(black_hole, pev_owner, id);
	
	//This is for a make safety remove ?
	// set_pev(ent, pev_nextthink, get_gametime() + 8.0) 
*/
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
