/* this is one of my first "complex" heroes, ty for the code scripts of Sasuke/AfterBurn, Goku, Marduk, Squall
use the idea of ??using goku's base that is by levels but instead of armor, use deaths, also take the idea 
of squall to be able to use active powers (key powers) with the knife. and I made the scripts for chidori, 
susanoo, as well as amaterasu, which is a modification of afterburn. Ty so much to "Natsheh" from the alliedmodders
forum, it helped me understand and how to make entities and touches.
*/
/*
v 1.2 = Add SendForwards for My own Hud.
v 1.1 = Add Pcvars Max Ammo Accumulative, Soved some erros about this pcvar accumulative.
v 1.0 = Creation Heroe
*/
/*
// Sasuke Uchiha
Uchiha_level 10		// Level 
Uchiha_killsreq 3	// Kills for pass of level

// Amaterasu
amaterasu_ammo 3	// Ammo Amaterasu for Level
amaterasu_burndecals 1	// Show Decal
amaterasu_burndmg 10	// Damage for Burn
amaterasu_numburns 10	// Time to burn
amaterasu_maxammoacum 7	// Max Ammo Amaterasu accumulative

// Chidori
chidori_ammo 2		// Ammo Chidori for Level
chidori_force 1500	// Force of Impulse
chidori_time 0.5	// Time to kill with Chidori/Impulse
chidori_damage 1400	// Damage
chidori_maxammoacum 3	// Max Ammo Chidori accumulative

// Susanoo
susano_speed 720	// Speed when u have susano
susano_hp 1800		// HP/AP when u have susano
susano_regenhp 20	// Regen HP for second to HP susanoo if u loose hp
susano_pctknife 0.75	// Percentage of blocking knife, 1.0 is max
susano_pctweapons 0.75	// Percentage of blocking bullets, 1.0 is max

// Tsukuyomi		
tsukuyomi_time 10	// This shows how long the event lasts, Tsukuyomi time = time - starting.
tuskuyomi_starting 5	// This shows everyone as soon as the tsukuyomi begins
tuskuyomi_respawn 2	// How many times can you revive your enemy after tsukuyomi activates and u are alive?

uchiha_adminflag a	// Only Adm? / 0 = For all
*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

// #include <amxmod>		// This is for respawn tsukuyomi	
#include <superheromod>
#include <Vexd_Utilities>

//Global Variables
new gHeroID
new gHeroName[]="Uchiha's Revenge" 
new bool:gHasUchihaPower[SH_MAXSLOTS+1]

// Counts, Pcvar, Bools Uchiha Levels
new gUchiCurrentLevel[SH_MAXSLOTS+1]
new KillCount[SH_MAXSLOTS+1]
new gUchihaLevel[4]
new PcvarKillsReq, HappyHudSync 

// Bools Amaterasu - Cvars Amaterasu
new amaterasu_shots[SH_MAXSLOTS+1], gIsBurning[SH_MAXSLOTS+1];
new gSpriteSmoke, gSpriteBurning, burndecals
new amaterasu_maxshots, pcvarBurnNum, pcvarBurnDmg, PcvarMaxAmaterasus

// Bool Chidori - Pcvars Chidori
new bool:touchChidoriPower[SH_MAXSLOTS+1], chidori_shots[SH_MAXSLOTS+1]
new PcvarForceChi, PcvarTimerChi, PcvarDamageChi, Chidori_maxshots, gSpriteSpark, PcvarMaxChidoris

// Pcvars Susanoo
new bool:gSusanoo[SH_MAXSLOTS+1]
// new iUserSusano[33]
new iUserSusano[SH_MAXSLOTS+1]
new PcvarSusanoSpeed, PcvarHPSusano, PcvarHealPoints, pcvarPercentKnife, pcvarPercentWeapons
// This is from Susanoo for dont loose speed when u switched weapons
new g_prevWeapon[SH_MAXSLOTS+1], g_lastWeapon[SH_MAXSLOTS+1], bool:g_weaponSwitched[SH_MAXSLOTS+1]

// Tuskoyomi
new bool:gInTsukuyomi[SH_MAXSLOTS + 1]
new pStTs[SH_MAXSLOTS+1], pTiTs[SH_MAXSLOTS+1]
new Float:SaveVelocs[SH_MAXSLOTS + 1][3], Float:iAngles[SH_MAXSLOTS + 1][3]
new Float:NullVeloc[3], Float:seconds 
new pcvarStartingTs, pcvarTimeTs, fwPreThink, pcvarTsukuyomiRespawns

new g_savedOrigin[SH_MAXSLOTS+1][3], g_lastPosition[SH_MAXSLOTS+1][3]
new KillCountTsukuyomi[SH_MAXSLOTS+1]
//----------------------------------------------------------------------------------------
//				Plugin Init						//
//----------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin( "SUPERHERO Uchiha", "1.0", " Lucas Cab 'Je :D' " )

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 		= register_cvar("Uchiha_level", "10" );		// Level 
	PcvarKillsReq 		= register_cvar("Uchiha_killsreq", "3");	// Kills for pass of level
	
	// Amaterasu
	amaterasu_maxshots	= register_cvar("amaterasu_ammo", "3");		// Ammo Amaterasu for Level
	burndecals		= register_cvar("amaterasu_burndecals", "1");	// Show Decal
	pcvarBurnDmg 		= register_cvar("amaterasu_burndmg","10");	// Damage for Burn
	pcvarBurnNum 		= register_cvar("amaterasu_numburns","10");	// Time to burn
	PcvarMaxAmaterasus	= register_cvar("amaterasu_maxammoacum","5");	// Max Ammo accumulative
	
	// Chidori
	PcvarForceChi		= register_cvar("chidori_force", "1500");	// Force of Impulse
	PcvarTimerChi		= register_cvar("chidori_time", "0.5");		// Time to kill with Chidori/Impulse
	PcvarDamageChi		= register_cvar("chidori_damage", "1400");	// Damage
	Chidori_maxshots	= register_cvar("chidori_ammo", "2");		// Ammo Chidori for Level
	PcvarMaxChidoris	= register_cvar("chidori_maxammoacum","3");	// Max Ammo accumulative
	
	// Susanoo
	PcvarSusanoSpeed	= register_cvar("susano_speed", "720");		// Speed when u have susano
	PcvarHPSusano		= register_cvar("susano_hp", "1800");		// HP/AP when u have susano
	PcvarHealPoints		= register_cvar("susano_regenhp", "20");	// Regen HP for second to HP susanoo if u loose hp
	pcvarPercentKnife 	= register_cvar("susano_pctknife", "0.75");	// Percentage of blocking knife, 1.0 is max
	pcvarPercentWeapons	= register_cvar("susano_pctweapons", "0.75");	// Percentage of blocking bullets, 1.0 is max
	
	// Tsukuyomi
	pcvarTimeTs		= register_cvar("tsukuyomi_time", "10");	// This shows how long the event lasts, Tsukuyomi time = time - starting.
	pcvarStartingTs		= register_cvar("tuskuyomi_starting", "5");	// This shows everyone as soon as the tsukuyomi begins
	pcvarTsukuyomiRespawns	= register_cvar("tuskuyomi_respawn", "2");	// How many times can you revive your enemy after tsukuyomi activates and u are alive?

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Gain Mangekyo Sharingan Powers.", "Assassin to evolve your sharingan, use the left/right click with the knife, chidori/amaterasu respectively.")
	
	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// CURRENT WEAPON - This is From Chidori.
	register_event("CurWeapon", "curweaponChidori", "be", "1=1")
	
	// CURRENT WEAPON - This is From Susanoo
	register_event("CurWeapon", "curweaponSusano", "be", "1=1")
	
	// DAMAGE - This is From Susano - Avoid damage that doesn't kill you and block it at once.
	register_event("Damage", "susano_damage", "b", "2!0")
	
	// Events of Tsukuyomi	
	register_forward( FM_PlayerPreThink , "fwPlayerPreThink" )
	RegisterHam( Ham_Player_Jump , "player" , "Player_Jump" , false )
	NullVeloc[0] = 0.0
	NullVeloc[1] = 0.0
	NullVeloc[2] = 0.0
	
	// Eventos Importantes para designar como tirar los poderes.
	// Chidori 
	RegisterHam(Ham_Weapon_PrimaryAttack, "weapon_knife", "Ham_Weapon_Attack1")
	// Amaterasu
	RegisterHam(Ham_Weapon_SecondaryAttack, "weapon_knife", "Ham_Weapon_Attack2")
	
	HappyHudSync = CreateHudSyncObj()
}
//----------------------------------------------------------------------------------------
//			Init Hero / Precache						//
//---------------------------------------------------------------------------------------- 
public sh_hero_init(id, heroID, mode)
{
	if (gHeroID != heroID) return
	//This is what runs when someone drops or picks the hero
	switch(mode) {
		case SH_HERO_ADD: {					// if the hero is added
			gHasUchihaPower[id] = true			// it is true that the client has the hero
			gUchiCurrentLevel[id] = 0
			KillCount[id] = 0
			pStTs[id] = -1					// From Tsukuyomi
			pTiTs[id] = -1  					// From Tsukuyomi
		}
		case SH_HERO_DROP: {					// if the hero is dropped
			gHasUchihaPower[id] = false			// it is false that the client has the hero
		}
	}	
	
	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public plugin_precache()
{
	// Sound - Sprites From Amaterasu
	precache_sound("shmod/amaterasuita.wav")
	gSpriteSmoke 	= 	precache_model("sprites/steam1.spr")
	gSpriteBurning 	= 	precache_model("sprites/shmod/purple_flame.spr")
	
	// Sound - Models From Chidori
	precache_model("models/shmod/v_narutonade.mdl")
	precache_sound("shmod/chidorisas.wav")
	gSpriteSpark 	= 	precache_model("sprites/shmod/chidori_spark.spr")
	
	// Model - Sprite From Susanoo
	precache_model("models/shmod/susanoo.mdl")
	// g_spritePowerUp2 = precache_model("sprites/shmod/purple_flame.spr")	// Use the same in Amaterasu.
	
	// Sound Tsukuyomi - This is default from cs
	precache_sound("ambience/port_suckin1.wav")
	precache_sound("ambience/3dmeagle.wav")
} 
//----------------------------------------------------------------------------------------
//				Load CVARS						//
//---------------------------------------------------------------------------------------- 
public plugin_cfg()  
{
	amaterasu_maxshots 	= 	get_cvar_num("amaterasu_ammo")		// Cvars - Amaterasu
	burndecals 		= 	get_cvar_num("amaterasu_burndecals")	// Cvars - Amaterasu
	Chidori_maxshots	=	get_cvar_num("chidori_ammo")		// Cvars - Chidori
	loadCVARS()
}

public loadCVARS()
{
	// These cvars are checked very often
	gUchihaLevel[0] = get_pcvar_num(PcvarKillsReq)
	gUchihaLevel[1] = gUchihaLevel[0] * 2
	gUchihaLevel[2] = gUchihaLevel[0] * 3
	gUchihaLevel[3] = gUchihaLevel[0] * 4 
} 
//----------------------------------------------------------------------------------------
//			Spawn / Death / Loop Hud Message				//
//----------------------------------------------------------------------------------------
public sh_client_spawn(id)
{	
	if (gHasUchihaPower[id]  && is_user_alive(id)) {
		// This is from Levels
		KillCount[id] = 0
		gUchiCurrentLevel[id] = 0

		// This is from Amaterasu
		amaterasu_shots[id] = 0
		Remove_Amaterasu(id)
	
		// This is from Chidori
		touchChidoriPower[id] = false
		chidori_shots[id] = 0
		
		// This is from Susanoo
		gSusanoo[id] = false
		Remove_Susano(id)
		
		// From Tsukuyomi
		pStTs[id] = -1
		pTiTs[id] = -1 
		
		sh_chat_message(id, gHeroID, "Necesitas matar a %d para Evolucionar tu Sharingan.", get_pcvar_num(PcvarKillsReq) )
	}
}
#if SEND_COOLDOWN
public sendUchihaLevel(id)
{
	new cooldown
	if ( gUchiCurrentLevel[id] > 0 )
		cooldown = gUchiCurrentLevel[id] 
	else
		cooldown = -1
	return cooldown
}

public sendUchihaChidori(id)
{
	new cooldown
	if ( chidori_shots[id] > 0 )
		cooldown = chidori_shots[id]
	else
		cooldown = -1
	return cooldown
} 

public sendUchihaAmaterasu(id)
{
	new cooldown
	if ( amaterasu_shots[id] > 0 )
		cooldown = amaterasu_shots[id]
	else
		cooldown = -1
	return cooldown
}
#endif
//----------------------------------------------------------------------------------------
//				Ham Event So Important					//
//----------------------------------------------------------------------------------------
public Ham_Weapon_Attack1(weaponent)			// Chidori in Left Click with Knife.
{
	new id = get_pdata_cbase(weaponent, 41, 4)
	if ( !is_user_alive(id) || !gHasUchihaPower[id] ) return
	if( get_user_weapon(id) != CSW_KNIFE ) return 
	
	// Para que sepa que usas el poder y va restando tenes 2 al nivel 2 y obtenes 2 cada nivel
	if( chidori_shots[id] != -1 ) {
		chidori_shots[id]--
	}
	 
	if(chidori_shots[id] <= 0) {
		sh_chat_message(id, gHeroID, "Recarga Chakra subiendo de Nivel para tener mÃ¡s Chidoris.")
	}
	
	// Chidori in Left Click with Knife.
	if ( gUchiCurrentLevel[id] >= 2 && chidori_shots[id] >= 0 ) {
		//Switch to Nade - Chidori
		sasuke_weapons(id)
		switchmodel(id)
		engclient_cmd(id, "weapon_flashbang")
		chidori(id)
		set_task(1.0, "unmodelnade", id)
	}
} 

public Ham_Weapon_Attack2(weaponent)			// Amaterasu in Right Click with Knife.
{
	new id = get_pdata_cbase(weaponent, 41, 4)
	if ( !is_user_alive(id) || !gHasUchihaPower[id] ) return
	if( get_user_weapon(id) != CSW_KNIFE ) return 
	
	// Para que sepa que usas el poder y va restando tenes 3
	if(amaterasu_shots[id] != -1 ) {
		amaterasu_shots[id]--
	}
	
	if(amaterasu_shots[id] <= 0) {
		sh_chat_message(id, gHeroID, "Recarga Chakra subiendo de Nivel para tener mÃ¡s Amaterasus.")
	}
	
	// Amaterasu in Right Click with Knife.
	if ( gUchiCurrentLevel[id] >= 1 && amaterasu_shots[id] >= 0) {
		amaterasu_shot(id)
		sh_screen_fade(id, 2.5, 2.5, 255, 10, 10, 50) 
	}
}
//----------------------------------------------------------------------------------------
//				Uchiha Evolucion					//
//----------------------------------------------------------------------------------------
public sh_client_death(victim, attacker)
{
	if ( !sh_is_active() || !sh_is_inround() ) return
	if ( victim == attacker || !is_user_alive(attacker) ) return
	 
	if ( gHasUchihaPower[attacker] ) {
		// KillCount = KillCount + 1
		KillCount[attacker]++
		// new id = attacker
		Uchiha_Evolve(attacker)
	}

	// if ( !gInTsukuyomi[victim] ) return 
	// This is from Phoenix Ty
	get_user_origin(victim, g_savedOrigin[victim])	// Save users origin on death
	g_savedOrigin[victim][2] += 8			// Save users origin on death
	// Look for self to raise from dead
	if ( !is_user_alive(victim) && gHasUchihaPower[attacker] && gUchiCurrentLevel[attacker] >= 4 && gSusanoo[attacker] && pStTs[attacker] <= 0 ) {
		new parm[1] 
		parm[0] = victim
		// Respawn him faster then Zues, let this power be used before Zues's
		// never set higher then 1.9 or lower then 0.5
		/* el task esta puesto en 0.x porque segun el mas chico se activa primero ese heroe.
		mangekyou = 0,5
		chucky = 0.6
		phoenix = 0.7
		shaman = 0.8
		dr.strange = 0.9
		majin buu = 1.0
		grandmaster = 1.1 // pero esta se superpone porque es la primera en usarse 
		uchiha revenge = 1.2
		torneo = 1.5 */
		set_task(1.2, "tsukuyomi_respawn", 0, parm, 1)
	} 
	
	
	if (  !is_user_alive(victim) && gHasUchihaPower[victim] ) {
		// From Amaterasu
		// Remove_Amaterasu(victim)
		// From Susanoo
		Remove_Susano(victim)
	}
	
	if ( !is_user_alive(victim) ) {
		// From Amaterasu
		gIsBurning[victim] = 0
		// Remove_Amaterasu()
		remove_task(victim)
		
		// From Tsukuyomi
		pStTs[victim] = -1
		pTiTs[victim] = -1  
	}
}

public Uchiha_Evolve(id)
{
	if (!shModActive()) return
	// Remember this weapon...   // this is for the speed found right.
	new clip, ammo, weaponID = get_user_weapon(id, clip, ammo)
	g_lastWeapon[id] = weaponID
	g_weaponSwitched[id] = true
	
	if (gHasUchihaPower[id] && is_user_alive(id)) {
		// For the Uchiha lvl 1 - Amaterasu
		if (KillCount[id] == get_pcvar_num(PcvarKillsReq) && KillCount[id] >= gUchihaLevel[0] && KillCount[id] < gUchihaLevel[1]) {
			if (gUchiCurrentLevel[id] < 1) {
				// recharge powers
				amaterasu_shots[id] = amaterasu_maxshots
				gUchiCurrentLevel[id] = 1
				sh_chat_message(id, gHeroID, "Amaterasu Habilitado! Activalo con el Click Derecho con la Faka.")
				}
			}
		// For the Uchiha lvl 2 - Chidori
		else if (KillCount[id] == get_pcvar_num(PcvarKillsReq) * 2 && KillCount[id] >= gUchihaLevel[1] && KillCount[id] < gUchihaLevel[2]) {
			if (gUchiCurrentLevel[id] < 2) {
				// recharge powers
				if ( amaterasu_shots[id] < 0 ) amaterasu_shots[id] = 0
				amaterasu_shots[id] = amaterasu_shots[id] + amaterasu_maxshots
				if ( amaterasu_shots[id] > get_pcvar_num(PcvarMaxAmaterasus) ) {
					amaterasu_shots[id] = get_pcvar_num(PcvarMaxAmaterasus)
				}
				
				chidori_shots[id] = Chidori_maxshots 
				gUchiCurrentLevel[id] = 2
				sh_chat_message(id, gHeroID, "Chidori Habilitado! Activalo con el Click Izquierdo con la Faka.")
				}
			}
		// For the Uchiha lvl 3 - Susanoo
		else if (KillCount[id] == get_pcvar_num(PcvarKillsReq) * 3 && KillCount[id] >= gUchihaLevel[2] && KillCount[id] < gUchihaLevel[3]) {
			if (gUchiCurrentLevel[id] < 3) {
				// recharge powers
				if ( amaterasu_shots[id] < 0 ) amaterasu_shots[id] = 0
				amaterasu_shots[id] = amaterasu_shots[id] + amaterasu_maxshots
				if ( amaterasu_shots[id] > get_pcvar_num(PcvarMaxAmaterasus) ) {
					amaterasu_shots[id] = get_pcvar_num(PcvarMaxAmaterasus)
				}
				
				if ( chidori_shots[id] < 0 ) chidori_shots[id] = 0
				chidori_shots[id] = chidori_shots[id] + Chidori_maxshots
				if ( chidori_shots[id] > get_pcvar_num(PcvarMaxChidoris) ) {
					chidori_shots[id] = get_pcvar_num(PcvarMaxChidoris)
				}
				
				gUchiCurrentLevel[id] = 3
				// Create de susanoo and boost
				gSusanoo[id] = true
				CreateSusa(id)
				susano_boost(id)
				sh_set_rendering(id, 154, 0, 210, 16, kRenderFxGlowShell)
				set_task(5.0, "susanoo_unglow", id)
				sh_chat_message(id, gHeroID, "Invocaste tu Propio Susanoo!")
				// Effect Susanoo
				new parm[2]
				parm[0] = id 
				parm[1] = 40
				susanoo_effect2(parm) 
				set_task(0.1, "susanoo_effect2", 0, parm, 2, "a", 200)
				// emit_sound(id, CHAN_STATIC, "shmod/goku_powerup3.wav", 0.8, ATTN_NORM, 0, PITCH_NORM)
				}
			}
		// For the Uchiha lvl 4 - Tsukuyomi ?¡
		else if (KillCount[id] == get_pcvar_num(PcvarKillsReq) * 4 && KillCount[id] >= gUchihaLevel[3]) {
			if (gUchiCurrentLevel[id] < 4) {
				// recharge powers
				if ( amaterasu_shots[id] < 0 ) amaterasu_shots[id] = 0
				amaterasu_shots[id] = amaterasu_shots[id] + amaterasu_maxshots
				if ( amaterasu_shots[id] > get_pcvar_num(PcvarMaxAmaterasus) ) {
					amaterasu_shots[id] = get_pcvar_num(PcvarMaxAmaterasus)
				}

				if ( chidori_shots[id] < 0 ) chidori_shots[id] = 0
				chidori_shots[id] = chidori_shots[id] + Chidori_maxshots
				if ( chidori_shots[id] > get_pcvar_num(PcvarMaxChidoris) ) {
					chidori_shots[id] = get_pcvar_num(PcvarMaxChidoris)
				}
				
				gUchiCurrentLevel[id] = 4
				// boost of susanoo
				gSusanoo[id] = true
				susano_boost(id)
				sh_set_rendering(id, 154, 0, 210, 16, kRenderFxGlowShell)
				set_task(5.0, "susanoo_unglow", id)
				sh_chat_message(id, gHeroID, "Estas Activando el Tsukuyomi Infinito.")
				// Effect Susanoo
				new parm[2]
				parm[0] = id 
				parm[1] = 40 
				susanoo_effect2(parm) 
				set_task(0.1, "susanoo_effect2", 0, parm, 2, "a", 200)
				ActiveTsuko(id)				// This is for active Tsukuyomi
				}
			}
		}
} 
//----------------------------------------------------------------------------------------
//					Amaterasu 					//
//----------------------------------------------------------------------------------------
public amaterasu_shot(id)
{
	if( !is_user_alive(id) || !gHasUchihaPower[id]) return PLUGIN_HANDLED

	new aimvec[3]			// Get position from eyes
	get_user_origin(id, aimvec, 3)	// Get position from eyes
	AmaterasuEffect(id, aimvec)	// Throw amaterasu effect

	// Get targeted player  -  -  In theory, this is so that if it hits it, it burns at once and not if or if I have to touch it.
	new tid, tbody 
	new FFOn = get_cvar_num("mp_friendlyfire")
	get_user_aiming(id, tid, tbody)
	if(is_user_alive(tid) && (FFOn || get_user_team(id) != get_user_team(tid))) {
		gIsBurning[tid] = 1
		new args[3]
		args[0] = tid
		args[1] = id  
		set_task( 0.3, "on_fire", 451, args, 3, "a", get_pcvar_num(pcvarBurnNum) ) 
		Remove_Amaterasu(id)
	}
	return PLUGIN_CONTINUE
}

public AmaterasuEffect(id, aimvec[3])
{
	if(!is_user_alive(id) || !gHasUchihaPower[id]) return
	
	emit_sound(id, CHAN_STATIC, "shmod/amaterasuita.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)
	
	new Float:vOrigin[3]
	vOrigin[0] += aimvec[0]
	vOrigin[1] += aimvec[1] 
	vOrigin[2] += aimvec[2] + 60
	
	new amaterasuaowner = id
	new amaterasu = create_entity("env_sprite")
	
	entity_set_string(amaterasu, EV_SZ_classname,"amaterasu") // entity classname, put what do you want here or leave it info_sprite...
	entity_set_model(amaterasu,"sprites/shmod/purple_flame.spr") // path to the sprite
	
	// ESto es para lograr la animacion del sprite - tiene que ir antes del movetype y solid_
	entity_set_float(amaterasu, EV_FL_animtime, 1.0) 		// I'm not entirely sure about this, but I think it is the time in which the sprite will animate.
	entity_set_float(amaterasu, EV_FL_framerate, 10.0)		// Frames per second.
	entity_set_int(amaterasu, EV_INT_spawnflags, SF_SPRITE_STARTON) 	// Essential if the animation is playing, I think.
	dllfunc( DLLFunc_Spawn, amaterasu ) 
	
	entity_set_edict(amaterasu, EV_ENT_owner, amaterasuaowner)	//para declarar el dueño de la entidad
	entity_set_int(amaterasu, EV_INT_solid, 2) 			// solid
	entity_set_int(amaterasu, EV_INT_movetype, 5) 			// don't move
	entity_set_float(amaterasu, EV_FL_scale, 0.6)			// para poner el tamaño del sprite x2.0 es el doble
	entity_set_size(amaterasu, Float:{-2.5, -2.5, -1.5}, Float:{2.5, 2.5, 1.5}) 	// tamaño?
	entity_set_vector(amaterasu, EV_VEC_origin, vOrigin) 		// donde se pone la entidad con vectores vorigin
	
	entity_set_int(amaterasu, EV_INT_rendermode, kRenderFxNoDissipation);		// necesario para quitar el fondo negro
	set_rendering(amaterasu, kRenderFxNoDissipation, _, _, _, kRenderGlow, 255) 	// put this to remove the black background of the sprite
	 
	 // REVISAR
	if(burndecals != 0) {
		// TE_GUNSHOTDECAL
		message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
		write_byte(109) 		// decal and ricochet sound
		write_coord(aimvec[0]) 		// pos
		write_coord(aimvec[1])
		write_coord(aimvec[2])
		write_short(0) 			// I have no idea what thats supposed to be
		write_byte(random_num(28, 30)) 	// decal
		message_end()
	}
}

public pfn_touch(ptr, ptd) 
{
	if(!is_valid_ent(ptd) || !is_valid_ent(ptr)) return PLUGIN_CONTINUE
	if(!is_user_connected(ptd) || !is_user_alive(ptd)) return PLUGIN_CONTINUE
	// Touch From Amaterasu
	new classname[32]
	entity_get_string(ptr, EV_SZ_classname, classname, 31)
	if(equal(classname, "amaterasu")) {
		//Declaro el dueño de la entidad anteriormente declarada en su creacion.
		new iOwner;
		iOwner = entity_get_edict(ptr, EV_ENT_owner);
		// para que evitar que la toquen los de tu team
		if( is_user_connected(iOwner) && get_user_team(iOwner) != get_user_team(ptd) ) {
			
			new args[3]
			args[0] = ptd
			args[1] = iOwner
			set_task(0.3, "on_fire", 451, args, 3, "a", get_pcvar_num(pcvarBurnNum)) 
			// This is for Amaterasu still on the ground after touched
			remove_entity(ptr);
		}
	}
	
	if(!is_valid_ent(ptd) || !is_valid_ent(ptr)) return PLUGIN_CONTINUE
	if(!is_user_connected(ptd) || !is_user_alive(ptd)) return PLUGIN_CONTINUE	
	// Touch From Chidori	
	new classname2[32]
	entity_get_string(ptr, EV_SZ_classname, classname2, 31)
	if ( equal(classname2, "player") ) {
		// para que evitar que la toquen los de tu team
		if ( gHasUchihaPower[ptr] && touchChidoriPower[ptr] && get_user_team(ptr) != get_user_team(ptd) ) {
			// Damage
			new damage = get_pcvar_num(PcvarDamageChi)
			sh_extra_damage(ptd, ptr, damage, "Por Chidori") 	// , 0, SH_DMG_KILL) if u wanna killdmg uncomment
		}	
	}
	
	return PLUGIN_CONTINUE 
} 

public on_fire(args[])
{
	new victim = args[0]
	new attacker = args[1]

	gIsBurning[victim] = 1
	
	if( !is_user_connected(victim) || !is_user_alive(victim) ) {
		gIsBurning[victim] = 0
		return
	}

	if (!gIsBurning[victim]) return 

	new rx, ry, rz, forigin[3]
	rx = random_num(-30, 30)
	ry = random_num(-30, 30)
	rz = random_num(-30, 30)
	get_user_origin(victim, forigin)

	//TE_SPRITE - additive sprite, plays 1 cycle
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(17)
	write_coord(forigin[0]+rx)	// coord, coord, coord (position)
	write_coord(forigin[1]+ry)
	write_coord(forigin[2]+10+rz)
	write_short(gSpriteBurning)	// short (sprite index)
	write_byte(30)				// byte (scale in 0.1's)
	write_byte(200)			// byte (brightness)
	message_end()

	//Smoke
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(5)
	write_coord(forigin[0]+(rx*2))	// coord, coord, coord (position)
	write_coord(forigin[1]+(ry*2))
	write_coord(forigin[2]+100+(rz*2))
	write_short(gSpriteSmoke)	// short (sprite index)
	write_byte(60)			// byte (scale in 0.1's)
	write_byte(15)			// byte (framerate)
	message_end()

	new health = get_user_health(victim)
	new damage = get_pcvar_num(pcvarBurnDmg)

	//Prevents the shExtraDamage from saying you attacked a teammate for every cycle of the loop
	if(health - damage  <= 0) {
		sh_extra_damage(victim, attacker, damage, "Fire")
		}
	else 	{
		set_user_health(victim, health - damage)
		//let them know who is hurting them with a flame
		set_user_maxspeed(victim, 300.0)
		
		new attackerName[32]
		get_user_name(attacker, attackerName, 31)
		sh_chat_message(victim, -1, "[%s] Te estÃ¡ quemando con su Amaterasu.", attackerName)
	}
}

public Remove_Amaterasu(id)
{
	new ent = 33;
	while((ent = find_ent_by_class(ent, "amaterasu")) != 0) {
		if( entity_get_edict(ent, EV_ENT_owner) != id )
			continue;
            
		remove_entity(ent);
	}
	/*/Como dice la funcion es para remover todas las entidades cada nueva ronda y/o muerte segun donde lo pongas
	new amaterasu = find_ent_by_class(-1, "amaterasu")
	while(amaterasu) {
		remove_entity(amaterasu)
		amaterasu = find_ent_by_class(amaterasu, "amaterasu")
	} */
}
//----------------------------------------------------------------------------------------
//					Chidori 					//
//----------------------------------------------------------------------------------------
public sasuke_weapons(id)
	if (shModActive() && is_user_alive(id)) sh_give_weapon(id, CSW_FLASHBANG)

public curweaponChidori(id)
{
	if ( !gHasUchihaPower[id] ||  !touchChidoriPower[id] ) return

	new wpnid = read_data(2)
	if ( wpnid != CSW_FLASHBANG ) return
	switchmodel(id)
}

switchmodel(id)
{
	if ( !is_user_alive(id) || !touchChidoriPower[id] ) return

	new clip, ammo, wpnid = get_user_weapon(id, clip, ammo)
	if ( wpnid == CSW_FLASHBANG ) {
		// Weapon Model change thanks to [CCC]Taz-Devil
		entity_set_string(id, EV_SZ_viewmodel, "models/shmod/v_narutonade.mdl") 
	}
}

public unmodelnade(id)
{
	if ( is_user_alive(id) ) {
		ham_strip_weapon(id, "weapon_flashbang")
		engclient_cmd(id, "weapon_knife")
	}
}

public chidori(id)
{
	// Stop the sound
	new sndStop=(2<<5)
	emit_sound(id, CHAN_STATIC, "shmod/chidorisas.wav", 1.0, ATTN_NORM, sndStop, PITCH_NORM)
	
	set_task( 0.1, "chidori_spark", id, "", 0, "a", 10 ) 
	
	// Esto trabaja asi cuanto mayor el segundo termino de vel_by_aim, mayor el dash que dara
	static Float:velocity[3]
	new PcvarVel = get_pcvar_num(PcvarForceChi)
	velocity_by_aim(id, PcvarVel, velocity)		// def = 1900 
	set_pev(id, pev_velocity, velocity) 		// velocity[0] = 1000.0 X //velocity[1] = 1000.0 Y //velocity[2] = 100.0 Z
	
	// Para que se habilite el daño del touch
	touchChidoriPower[id] = true			// For touch damage to be enabled
	
	// Esto es para que se quite el touck kill/damage despues del salto masomenos
	set_task(get_pcvar_float(PcvarTimerChi), "untouchkatana", id)		//	def = 1.0
	 
	// Esto es para darle un glow
	sh_set_rendering(id, 141, 143, 144, 16, kRenderFxGlowShell)
	set_task(get_pcvar_float(PcvarTimerChi), "chidori_unglow", id) 
}
//---------------------------	ACLARACION TODOS LOS TOUCH VAN AL AMATERASU
// public pfn_touch(ptr, ptd)// CLARIFICATION ALL TOUCH GO TO AMATERASU
public untouchkatana(id)
	touchChidoriPower[id] = false

public chidori_unglow(id)
	sh_set_rendering(id)
	
public chidori_spark(id)
{	
	new rx, ry, origin[3]
	rx = random_num(-10, 10)
	ry = random_num(-10, 10)
	// rz = random_num(-15, 15)
	get_user_origin(id, origin)

	//TE_SPRITE - additive sprite, plays 1 cycle
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(17)
	write_coord(origin[0]+rx)	// coord, coord, coord (position)
	write_coord(origin[1]+ry)
	write_coord(origin[2]+10) //+rz)
	write_short(gSpriteSpark)	// short (sprite index)
	write_byte(2)			// byte (scale in 0.1's)
	write_byte(250)			// byte (brightness)
	message_end()
}
//------	Stock 	Para Quitar Armas	----------
stock ham_strip_weapon(id,weapon[])
{
	if(!equal(weapon,"weapon_",7)) return 0;

	new wId = get_weaponid(weapon);
	if(!wId) return 0;

	new wEnt;
	while((wEnt = engfunc(EngFunc_FindEntityByString,wEnt,"classname",weapon)) && pev(wEnt,pev_owner) != id) {}
	if(!wEnt) return 0;

	if(get_user_weapon(id) == wId) ExecuteHamB(Ham_Weapon_RetireWeapon,wEnt);

	if(!ExecuteHamB(Ham_RemovePlayerItem,id,wEnt)) return 0;
	ExecuteHamB(Ham_Item_Kill,wEnt);

	set_pev(id,pev_weapons,pev(id,pev_weapons) & ~(1<<wId));

	return 1;
} 
//----------------------------------------------------------------------------------------
//					Susanoo						//
//----------------------------------------------------------------------------------------
public susano_boost(id)
{
	if ( !gHasUchihaPower[id] || !is_user_alive(id) ) return
	
	if ( gSusanoo[id] && gUchiCurrentLevel[id] >= 3 ) {
		// Set boost of Susanoo
		set_user_maxspeed( id, get_pcvar_float(PcvarSusanoSpeed) );
		new NewHP 	= get_pcvar_num(PcvarHPSusano)	// def 1800
		set_user_health( id, NewHP )
		set_user_armor( id, NewHP )
		set_task(1.0, "susano_loop", id, _, _, "b") 	// HEAL LOOP
	}
}

public curweaponSusano(id)
{
	new wpnid = read_data(2)
	if ( g_prevWeapon[id] != wpnid && gSusanoo[id] && is_user_alive(id) ) {
		set_user_maxspeed( id, get_pcvar_float(PcvarSusanoSpeed) );
	}
	g_prevWeapon[id] = wpnid
}

public susano_loop(id)
{
	new players[SH_MAXSLOTS], pnum
	get_players(players, pnum, "a")
	for ( new id = 1; id <= pnum; id++ ) {
		if ( gSusanoo[id] && is_user_alive(id) ) {
			//Set loop for more hp
			new NewHP  	= get_pcvar_num(PcvarHPSusano)	// def 1800
			new gHealPoints	= get_pcvar_num(PcvarHealPoints)
			shAddHPs(id, gHealPoints, NewHP)
			}
		}
}

public susano_damage(id)
{
	if ( !gSusanoo[id] || !is_user_alive(id) ) return

	new damage = read_data(2)
	new weapon, bodypart, attacker = get_user_attacker(id,weapon,bodypart)
	
	new randnum = random_num(0, 100)
	new susanochancheK = floatround(get_pcvar_float(pcvarPercentKnife) * 100)
	new u_health = get_user_health(id)
	new newlife = u_health + damage + 1
	// this put this form beacuse block if u dont died
	if ( susanochancheK >= randnum  && id != attacker && weapon==CSW_KNIFE && bodypart!=HIT_HEAD ) {
		
		shAddHPs(id, damage, newlife) 
		set_hudmessage(0, 100, 200, 0.05, 0.63, 1, 0.1, 2.0, 0.1, 0.1, 3)
		show_hudmessage(id, "[%s] Blockeaste un Fakaso con Susanoo!", gHeroName)
	} 
	// this put this form beacuse block if u dont died
	new u_armor = get_user_armor(id)
	new new_armor = u_armor - damage 		//(damage * 2)
	new susanochancheW = floatround(get_pcvar_float(pcvarPercentWeapons) * 100)
	
	if ( u_armor > 500 && susanochancheK >= randnum || susanochancheW >= randnum ) {
		
		shAddHPs(id, damage, newlife)
		set_user_armor(id, new_armor)
		if ( weapon == CSW_KNIFE ) {
			set_hudmessage(0, 100, 200, 0.05, 0.60, 1, 0.1, 2.0, 0.1, 0.1, 3)
			show_hudmessage(id, "[%s] Blockeaste un Fakaso con Susanoo!", gHeroName)
		}
	}
}

CreateSusa(id)
{
	new susanowner = id
	new susanoo = create_entity("info_target")
	
	iUserSusano[id] = susanoo
	if ( !pev_valid(susanoo) ) return
    
	set_pev(susanoo, pev_classname, "susanoo")		// name of ent
	entity_set_model(susanoo, "models/shmod/susanoo.mdl")	// model
	
	set_pev(susanoo, pev_solid, SOLID_TRIGGER); 		// touch on edge, block  SOLID_BBOX    
	set_pev(susanoo, pev_movetype, MOVETYPE_FOLLOW)		// follor player id MOVETYPE_FOLLOW
	set_pev(susanoo, pev_aiment, susanowner)		// owner	
	set_pev(susanoo, pev_framerate, 1.0)			// This is for animation? 
	set_pev(susanoo, pev_animtime, get_gametime() )		// This is for animation? 
	set_pev(susanoo, pev_sequence, 0)			// What is sequence?
	// Glow ?
	new Float:glowColor[3] = {154.0, 0.0, 210.0}
	set_pev(susanoo, pev_renderfx, kRenderFxGlowShell)	
	set_pev(susanoo, pev_rendercolor, glowColor)	
	set_pev(susanoo, pev_rendermode, kRenderTransAlpha)	
	set_pev(susanoo, pev_renderamt, 40.0)	// def 40
	// set_rendering(susanoo, kRenderFxGlowShell, 154, 0, 210, kRenderNormal, 25); // I use this for glow entity , Es otra forma pero recomiendo la anterior
 
	fm_set_entity_visibility(susanoo, 1)
}

// called to make ent invisible or render it to 100
stock fm_set_entity_visibility(index, visible = 1)
{
	if( !visible ) {
		fm_set_rendering(index, kRenderFxGlowShell, kRenderNormal, 0)
		return;
	}
	
	fm_set_rendering(index, kRenderFxGlowShell, kRenderNormal, 100 )
}

stock fm_set_rendering(entity, fx = kRenderFxNone, kRender, amount = 16) 
{
	set_pev(entity, pev_renderfx, fx)
	set_pev(entity, pev_rendermode, kRender)
	set_pev(entity, pev_renderamt, float(amount))
}
//--------- Thanx to vittu for this code.
public susanoo_effect2(parm[])
{
	if ( !shModActive() || !sh_is_inround() ) return
	
	new id = parm[0]
	if ( !is_user_alive(id) ) return
 
	new Size = parm[1]
	new players[SH_MAXSLOTS], pnum
	new idOthers, Origin[3]

	get_players(players, pnum, "a")
	// Show a powerup to all alive players except the one being powered up.
	for (new i = 0; i < pnum; i++) {
		idOthers = players[i]
		if ( !is_user_alive(idOthers) || idOthers == id ) continue		// con esto no dejo que vea su sprite
		// if ( !is_user_alive(idOthers) ) continue					// con esto si lo ve xd
		get_user_origin(id, Origin)

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteBurning)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0]+5) // center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteBurning)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0]-5)	// center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteBurning)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1]+5)
		write_coord(Origin[2]+10)
		write_short(gSpriteBurning)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1]-5)
		write_coord(Origin[2]+10)
		write_short(gSpriteBurning)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()
	}
} 

public susanoo_unglow(id)
	sh_set_rendering(id)

Remove_Susano(id)
{
	new susanoo = iUserSusano[id]
	if(susanoo != -1 && pev_valid(susanoo)) {
		new szClassname[32];
		pev(susanoo, pev_classname, szClassname, 31);
		if(equal(szClassname, "susanoo")) {
			set_pev(susanoo, pev_flags, FL_KILLME)
			dllfunc(DLLFunc_Think, susanoo)
			iUserSusano[id] = -1;
		}
	}
}
//----------------------------------------------------------------------------------------
//					Tsukuyomi					//
//----------------------------------------------------------------------------------------
public ActiveTsuko(id)
{
	if ( !sh_is_inround() ) return

	seconds = ( get_pcvar_float(pcvarTimeTs)-get_pcvar_float(pcvarStartingTs) )
	// Timer LOOP_players/id show the huds
	pStTs[id] = get_pcvar_num(pcvarStartingTs)
	pTiTs[id] = ( get_pcvar_num(pcvarTimeTs)-get_pcvar_num(pcvarStartingTs)+1 )
	
	new players[SH_MAXSLOTS], pnum, player
	get_players(players, pnum, "a")
	for (new i = 0; i < pnum; i++) {
		player = players[i]
		if( is_user_alive(player) && !gInTsukuyomi[player] ) {
			set_task(get_pcvar_float(pcvarStartingTs), "Tsukuyomi", player)
			set_task(1.0, "tsukustart_playerhud", player, "", 0, "b")
			}
		}
}

public tsukustart_playerhud(player)
{
	new id = player
	if ( !sh_is_inround() || !is_user_alive(player) ) return
	
	// Loop Aviso de Inicio -
	if ( pStTs[id] > 0 ) {
		pStTs[id]--
		if ( pStTs[id] <= get_pcvar_num(pcvarStartingTs) )  {
			set_hudmessage( 50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 4)
			ShowSyncHudMsg( player, HappyHudSync, "El Tsukuyomi Infinito empezarÃ¡ en %d segundos.", pStTs[id] )
		}
	}  
	// Loop Duracion del Evento Tsukuyomi
	new pTiTsNum = ( get_pcvar_num(pcvarTimeTs)-get_pcvar_num(pcvarStartingTs) )
	
	if ( pStTs[id] <= 0 ) {
		pTiTs[id]--
		if ( pTiTs[id] <= pTiTsNum && pTiTs[id] > 0) {
			set_hudmessage( 50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 4)
			ShowSyncHudMsg( player, HappyHudSync, "El Tsukuyomi Infinito terminarÃ¡ en %d segundos.", pTiTs[id] )
		} 
	} 
	if ( pTiTsNum == 0 ) return
}

public Tsukuyomi(player)
{
	if ( !sh_is_inround() ) return 
	
	if ( !gSusanoo[player] && !gHasUchihaPower[player] ) {
		
		gInTsukuyomi[player] = true		// Si esta en un tsukuyomi ahora
		sh_set_stun( player, seconds, 1.0)	//stun here, unless we want to pass seconds to the function as well.
		
		pev(player, pev_v_angle, iAngles[ player ])	
		Entvars_Get_Vector(player,EV_VEC_velocity,SaveVelocs[player])
		sh_screen_fade( player, seconds, seconds, 148, 148, 148, 148 )	//make screen gray
	
		new parm[1]
		parm[0] = player 
		set_task( seconds, "tsukuyomi_end", 0, parm, 1)
		if ( !is_user_alive(player) ) { // && gInTsukuyomi[player] ) { 
			set_task( 0.1, "tsukuyomi_end", 0, parm, 1)
		}
	}
}

public tsukuyomi_end(parm[0])
{
	new id = parm[0]
	pStTs[id] = -1
	pTiTs[id] = -1  
	gInTsukuyomi[id] = false
	
	sh_reset_max_speed(id)
	sh_reset_min_gravity(id)
	set_pdata_int (id, 83, -1)
	Entvars_Set_Vector( id, EV_VEC_velocity, SaveVelocs[id]) 
	
	set_hudmessage(50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 3)
	show_hudmessage(id, "Te liberaste del Genjutsu Tsukuyomi Infinito terminÃ³.")
	// ShowSyncHudMsg( id, HappyHudSync, "Te liberaste del Genjutsu Tsukuyomi Infinito terminÃ³.")
	remove_task(id)
}

public fwPlayerPreThink(id)
{
	if( !is_user_connected(id) || !is_user_alive(id) ) return
	if( !gInTsukuyomi[id] || !sh_is_inround() ) return
 
	set_user_gravity(id, 0.001)
	set_pdata_int ( id, 83, 999 )
	set_pev( id , pev_fixangle , 1 ) 		//aimfreeze
	set_pev( id , pev_v_angle , iAngles[ id ] )	//aimfreeze
	Entvars_Set_Vector(id, EV_VEC_velocity, NullVeloc)	
}

public Player_Jump(id)
{
	if( gInTsukuyomi[id] ) {
		return HAM_SUPERCEDE;
	}
	return HAM_IGNORED;
}

public tsukuyomi_respawn(parm[])
{
	new victim = parm[0]
	if ( !is_user_connected(victim) || is_user_alive(victim) || !sh_is_inround() ) return
	if ( KillCountTsukuyomi[victim] == get_pcvar_num(pcvarTsukuyomiRespawns) ) return

	emit_sound(victim, CHAN_STATIC, "ambience/port_suckin1.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)
	sh_chat_message(victim, -1, "El Tsukuyomi te reviviÃ³ para matarte otra vez en su Genjutsu.")
	
	// Double spawn prevents the no HUD glitch
	//user_spawn(victim)
	//user_spawn(victim)
	KillCountTsukuyomi[victim]++
	ExecuteHamB(Ham_CS_RoundRespawn, victim) 	// Dont use this cause bugs
	
	emit_sound(victim, CHAN_STATIC, "ambience/3dmeagle.wav", 0.6, ATTN_NORM, 0, PITCH_NORM)
	sh_screen_fade( victim, seconds, seconds, 148, 148, 148, 148 )	//make screen gray
	sh_set_rendering(victim, 141, 143, 144, 16, kRenderFxGlowShell)	// Glow
	set_task(1.0, "tsukuyomi_unglow2", victim) 			// Unglow
	set_user_health(victim, 500)					// Set HP after respawn
	tsukuyomi_teleport(victim)
}

public tsukuyomi_teleport(victim)
{
	// Teleport the player
	set_user_origin(victim, g_savedOrigin[victim])
	// Teleport Effects
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(11)					// TE_TELEPORT
	write_coord(g_savedOrigin[victim][0])		// start position
	write_coord(g_savedOrigin[victim][1])
	write_coord(g_savedOrigin[victim][2])
	message_end()
	positionChangeTimer_tsukuyomi(victim)
}

public positionChangeTimer_tsukuyomi(victim)
{
	if ( !is_user_alive(victim) ) return
	
	new Float:velocity[3]
	get_user_origin(victim, g_lastPosition[victim])
	Entvars_Get_Vector(victim, EV_VEC_velocity, velocity)

	if ( velocity[0]==0.0 && velocity[1]==0.0 ) {
		// Force a Move (small jump)
		velocity[0] += 20.0
		velocity[2] += 100.0
		Entvars_Set_Vector(victim, EV_VEC_velocity, velocity)
	}
	set_task(0.4, "positionChangeCheck_tsukuyomi", victim+100)
}

public positionChangeCheck_tsukuyomi(victim)
{
	victim -= 100
	if ( !is_user_alive(victim) ) return

	new origin[3]
	get_user_origin(victim, origin)
	// Kill this player if Stuck in Wall!
	if ( g_lastPosition[victim][0] == origin[0] && g_lastPosition[victim][1] == origin[1] && g_lastPosition[victim][2] == origin[2] && is_user_alive(victim) ) {
		user_kill(victim, 1)
		sh_chat_message(victim, -1, "Te moriste por quedar bugeado en el respawn del %s.", gHeroName)
	}
}

public tsukuyomi_unglow2(victim)
	sh_set_rendering(victim)

public sh_round_end()
{
	static players[32], count, i, id	
	get_players(players, count, "")
	
	for ( i = 0; i < count; i++ ) {
		id = players[i]
		
		if ( gInTsukuyomi[id] ) {
		// for (new id=0; id <= SH_MAXSLOTS; id++) {
			remove_task(id)
			KillCountTsukuyomi[id] = 0 
			new parm[1]
			parm[0] = id
			tsukuyomi_end(parm[0])
		}
	}
}
//----------------------------------------------------------------------------------------
//			Client_disconnected / Admin Check				//
//----------------------------------------------------------------------------------------
public client_disconnected(id)
{
	// This is From Amaterasu	// stupid check but lets see
	if(id <= 0 || id > SH_MAXSLOTS) return
	// Yeah don't want any left over residuals
	remove_task(id)
	gHasUchihaPower[id] = false
	
	// This is From Susanoo
	Remove_Susano(id)
	iUserSusano[id] = -1; 
	
	// This is From Tsukuyomi
	gInTsukuyomi[id] = false
	set_user_info(id, "ShStunned", "0")
	if( fwPreThink ) unregister_forward( FM_PlayerPreThink , fwPreThink )
}
//----------------------------------------------------------------------------------------
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1030\\ f0\\ fs16 \n\\ par }
*/
