/* this is one of my first "complex" heroes, ty for the code scripts of Sasuke/AfterBurn, Goku, Marduk, Squall
use the idea of ??using goku's base that is by levels but instead of armor, use deaths, also take the idea 
of squall to be able to use active powers (key powers) with the knife. and I made the scripts for chidori, 
susanoo, as well as amaterasu, which is a modification of afterburn. Ty so much to "Natsheh" from the alliedmodders
forum, it helped me understand and how to make entities and touches.
*/
/*
v 1.2 = Add SendForwards for My own Hud.
v 1.1 = Add Pcvars Max Ammo Accumulative, Soved some erros about this pcvar accumulative.
v 1.0 = Creation Heroe
*/
/*
// Sasuke Uchiha
Uchiha_level 10		// Level 
Uchiha_killsreq 3	// Kills for pass of level

// Amaterasu
amaterasu_ammo 3	// Ammo Amaterasu for Level
amaterasu_burndmg 10	// Damage for Burn
amaterasu_numburns 10	// Time to burn

// Chidori
chidori_ammo 2		// Ammo Chidori for Level
chidori_damage 1400	// Damage

// Susanoo
susano_speed 720	// Speed when u have susano
susano_hp 1800		// HP/AP when u have susano
susano_regenhp 20	// Regen HP for second to HP susanoo if u loose hp
susano_pctknife 75	// Percentage of blocking knife, 1.0 is max

// Tsukuyomi		
tsukuyomi_time 10	// This shows how long the event lasts, Tsukuyomi time = time - starting.
tuskuyomi_starting 5	// This shows everyone as soon as the tsukuyomi begins
tuskuyomi_respawn 2	// How many times can you revive your enemy after tsukuyomi activates and u are alive?

*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1
	
#include <superheromod>

//Global Variables
new gHeroID
new gHeroName[] = "Uchiha's Revenge" 
new bool:gHasUchihaPower[SH_MAXSLOTS+1]

// Counts, Pcvar, Bools Uchiha Levels
new gUchihaCurrentLevel[SH_MAXSLOTS+1]
new gKillCount[SH_MAXSLOTS+1]
new gUchihaLevel[4]
new PcvarKillsReq, HappyHudSync  

// Bools Amaterasu - Cvars Amaterasu
new gAmaterasu_shots[SH_MAXSLOTS+1], gIsBurning[SH_MAXSLOTS+1];

new const gAmaterasu_Ent_Name[] 		= "Amaterasu"
new const gAmaterasu_Ent_Model[]	= "sprites/shmod/purple_flame.spr"
new const gAmaterasu_Sound[]		= "shmod/amaterasuita.wav"

new gPcvar_Ama_ammo, gPcvar_Ama_Burn_Num, gPcvar_Ama_Dmg
new gSpriteSmoke, gSpriteAmaterasu, pcvar_Ama_Burn_Num

// Bool Chidori - Pcvars Chidori
new bool:touchChidoriPower[SH_MAXSLOTS+1], chidori_shots[SH_MAXSLOTS+1]

new const gChidori_model[] 		= "models/shmod/v_narutonade.mdl"
new const gChidori_sprite[] 		= "sprites/shmod/chidori_spark.spr"
new const gChidori_sound[] 		= "shmod/chidorisas.wav"

new gSpriteSpark, gPcvarChi_Dmg, gPcvarChi_Ammo, pcvarChi_Dmg

// Pcvars Susanoo
new iUserSusano[SH_MAXSLOTS+1], g_prevWeapon[SH_MAXSLOTS+1]

new const gSusanoo_model[] 		= "models/shmod/susanoo.mdl"
new const gSusanoo_name[] 		= "Susano'o"

new PcvarSusanoSpeed, PcvarHPSusano, PcvarHealPoints, pcvarPercentKnife

// Tuskoyomi
new bool:gInTsukuyomi[SH_MAXSLOTS + 1]

new gTimer_Tsuku[SH_MAXSLOTS+1], KillCountTsukuyomi[SH_MAXSLOTS+1]
new Float: start_time_float, start_time_num
new pcvarStartingTs, pcvarTimeTs, pcvarTsukuyomiRespawns

// for  unstuck tsukuyomi
new Float:gFVecOrigin[SH_MAXSLOTS+1][3]
new Float:gFVecAngles[SH_MAXSLOTS+1][3]

new const Float:VEC_DUCK_HULL_MIN[3]	= {-16.0, -16.0, -18.0 }
new const Float:VEC_DUCK_HULL_MAX[3]	= { 16.0,  16.0,  32.0 }
new const Float:VEC_DUCK_VIEW[3]	= {  0.0,   0.0,  12.0 }
new const Float:VEC_NULL[3]		= {  0.0,   0.0,   0.0 }

new const gSoundReBirth[] 	= "ambience/port_suckin1.wav"
new const gSoundEagle[] 		= "ambience/3dmeagle.wav"
//----------------------------------------------------------------------------------------
//				Plugin Init						//
//----------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin( "SUPERHERO Uchiha", "1.0", " Lucas Cab 'Je :D' " )

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 		= register_cvar("Uchiha_level", "10" );		// Level 
	PcvarKillsReq 		= register_cvar("Uchiha_killsreq", "3");	// Kills for pass of level
	
	// Amaterasu
	gPcvar_Ama_ammo		= register_cvar("amaterasu_ammo", "3");		// Ammo Amaterasu for Level
	gPcvar_Ama_Dmg 		= register_cvar("amaterasu_burndmg","10");	// Damage for Burn
	pcvar_Ama_Burn_Num	= register_cvar("amaterasu_numburns","10");	// Time to burn
	
	// Chidori
	pcvarChi_Dmg		= register_cvar("chidori_damage", "1400");	// Damage
	gPcvarChi_Ammo		= register_cvar("chidori_ammo", "2");		// Ammo Chidori for Level
	
	// Susanoo
	PcvarSusanoSpeed	= register_cvar("susano_speed", "720");		// Speed when u have susano
	PcvarHPSusano		= register_cvar("susano_hp", "1800");		// HP/AP when u have susano
	PcvarHealPoints		= register_cvar("susano_regenhp", "20");	// Regen HP for second to HP susanoo if u loose hp
	pcvarPercentKnife 	= register_cvar("susano_pctknife", "25");	// Percentage of blocking knife, 100 is max
	
	// Tsukuyomi
	pcvarTimeTs		= register_cvar("tsukuyomi_time", "10");	// This shows how long the event lasts, Tsukuyomi time = time - starting.
	pcvarStartingTs		= register_cvar("tuskuyomi_starting", "5");	// This shows everyone as soon as the tsukuyomi begins
	pcvarTsukuyomiRespawns	= register_cvar("tuskuyomi_respawn", "2");	// How many times can you revive your enemy after tsukuyomi activates and u are alive?

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Gain Mangekyo Sharingan Powers.", "Assassin to evolve your sharingan, use the left/right click with the knife, chidori/amaterasu respectively.")
	
	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	
	// EVENTS FOR AMATERASU - CHIDORI
	register_touch("player","player","amaterasu_chidori_touch")		// Touch
	register_touch(gAmaterasu_Ent_Name,"player","amaterasu_chidori_touch")	// Touch
	
	// CURRENT WEAPON - This is From Chidori.- Susanoo
	register_event("CurWeapon", "curweapon_chidori_sunasoo", "be", "1=1")
	
	// DAMAGE - This is From Susano - Avoid damage that doesn't kill you and block it at once.
	RegisterHam(Ham_TakeDamage, "player", "Fw_TakeDamage_Pre", 0)
	
	// Events of Tsukuyomi	
	RegisterHam( Ham_Player_Jump , "player" , "Player_Jump" , false )
	
	// EVENTS FOR AMATERASU N CHIDORI
	RegisterHam(Ham_Weapon_PrimaryAttack, "weapon_knife", "Ham_Weapon_Attack1")	// Hook pimrary attack
	RegisterHam(Ham_Weapon_SecondaryAttack, "weapon_knife", "Ham_Weapon_Attack2")	// Hook Second attack
	
	HappyHudSync = CreateHudSyncObj()
}
//----------------------------------------------------------------------------------------
//			Init Hero / Precache						//
//---------------------------------------------------------------------------------------- 
public sh_hero_init(id, heroID, mode)
{
	if (gHeroID != heroID) return
	//This is what runs when someone drops or picks the hero
	switch(mode) {
		case SH_HERO_ADD: {					// if the hero is added
			gHasUchihaPower[id] = true			// it is true that the client has the hero

			reset_counts(id)
			reset_chidori(id)
			tsukuyomi_reset(id)
			remove_susanoo(id)
			remove_amaterasu(id)
		}
		case SH_HERO_DROP: {					// if the hero is dropped
			gHasUchihaPower[id] = false			// it is false that the client has the hero
			
			reset_chidori(id)
			tsukuyomi_reset(id)
			remove_susanoo(id)
			remove_amaterasu(id)
		}
	}	
	
	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public plugin_precache()
{
	// Sound - Sprites From Amaterasu
	precache_sound(gAmaterasu_Sound)
	gSpriteSmoke 	= 	precache_model("sprites/steam1.spr")
	gSpriteAmaterasu = 	precache_model(gAmaterasu_Ent_Model)
	
	// Sound - Models From Chidori 
	precache_model(gChidori_model)
	precache_sound(gChidori_sound)
	gSpriteSpark 	= 	precache_model(gChidori_sprite)
	
	// Model - Sprite From Susanoo
	precache_model(gSusanoo_model)
	// g_spritePowerUp2 = precache_model("sprites/shmod/purple_flame.spr")	// Use the same in Amaterasu.
	
	// Sound Tsukuyomi - This is default from cs
	precache_sound(gSoundReBirth)
	precache_sound(gSoundEagle)
} 
//----------------------------------------------------------------------------------------
//				Load CVARS						//
//---------------------------------------------------------------------------------------- 
public plugin_cfg()  
	loadCVARS()

public loadCVARS()
{
	gPcvar_Ama_Burn_Num	= 	get_pcvar_num(pcvar_Ama_Burn_Num)	// Cvars - Amaterasu
	gPcvarChi_Dmg		=	get_pcvar_num(pcvarChi_Dmg)		// Cvars - Chidori
	
	start_time_float	= 	get_pcvar_float(pcvarStartingTs)
	start_time_num  	=	get_pcvar_num(pcvarStartingTs)
	
	// These cvars are checked very often
	gUchihaLevel[0] = get_pcvar_num(PcvarKillsReq)
	gUchihaLevel[1] = gUchihaLevel[0] * 2
	gUchihaLevel[2] = gUchihaLevel[0] * 3
	gUchihaLevel[3] = gUchihaLevel[0] * 4 
} 
//----------------------------------------------------------------------------------------
//			Spawn , Resets And start					//
//----------------------------------------------------------------------------------------
public sh_client_spawn(id)
{	
	if ( gInTsukuyomi[id] ) {
		tsukuyomi_reset(id)			// From tsukuyomi
		remove_task(id)
	}
	
	gIsBurning[id] = false		// From Amaterasu 
	
	if ( gHasUchihaPower[id] ) {
		// reset this variables
		reset_counts(id)
		reset_chidori(id)
		remove_susanoo(id)
		remove_amaterasu(id)
	}
} 

public reset_counts(id) {
	gKillCount[id] = 0
	gUchihaCurrentLevel[id] = 0
	
	gAmaterasu_shots[id] = 0
	chidori_shots[id] = 0
}

public sh_round_new()
{
	static players[32], count, i, id	
	get_players(players, count, "ah")
	for ( i = 1; i <= count; i++ ) {
		id = players[i]
		if ( !gHasUchihaPower[id] ) continue 
		sh_chat_message(id, gHeroID, "Necesitas matar a %d para Evolucionar tu Sharingan.", get_pcvar_num(PcvarKillsReq) )
	}
}
public sh_round_end()
{
	static players[32], count, i, id	
	get_players(players, count, "")
	for ( i = 0; i < count; i++ ) {
		id = players[i]

		if ( gHasUchihaPower[id] ) {
			// reset this variables
			reset_counts(id)
			reset_chidori(id)
			remove_susanoo(id)
			remove_amaterasu(id)
		}
		
		KillCountTsukuyomi[id] = 0
		
		if ( gInTsukuyomi[id] ) {
			tsukuyomi_reset(id)			// From tsukuyomi
			remove_task(id)
		}
	}
}
//----------------------------------------------------------------------------------------
//				Uchiha Evolucion					//
//----------------------------------------------------------------------------------------
public sh_client_death(victim, attacker)
{
	if ( !sh_is_active() || !sh_is_inround() ) return
	if ( victim == attacker ) return
	 
	if ( gHasUchihaPower[attacker] && is_user_alive(attacker) ) {
		gKillCount[attacker]++
		uchiha_evolve(attacker)
	}

	// Save users origin on death
	pev(victim, pev_origin, gFVecOrigin[victim])
	pev(victim, pev_v_angle, gFVecAngles[victim])
	// Look for self to raise from dead
	if ( gUchihaCurrentLevel[attacker] >= 4 && gInTsukuyomi[victim] ) {
		new parm[1] 
		parm[0] = victim
		// Respawn him faster then Zues, let this power be used before Zues's
		// never set higher then 1.9 or lower then 0.5
		/* el task esta puesto en 0.x porque segun el mas chico se activa primero ese heroe.
		mangekyou = 0,5
		chucky = 0.6
		phoenix = 0.7
		shaman = 0.8
		dr.strange = 0.9
		majin buu = 1.0
		grandmaster = 1.1 // pero esta se superpone porque es la primera en usarse 
		uchiha revenge = 1.2
		torneo = 1.5 */
		set_task(1.2, "tsukuyomi_respawn", 0, parm, 1)
	} 
	
	
	if ( gHasUchihaPower[victim] ) {
		// From Amaterasu
		remove_amaterasu(victim)
		// From Susanoo
		remove_susanoo(victim)
	}
	

	// From Amaterasu 
	gIsBurning[victim] = false
}

public uchiha_evolve(id)
{
	if ( !sh_is_active() || !sh_is_inround() ) return
	
	for ( new iLevel = 0 ; iLevel < sizeof(gUchihaLevel) ; iLevel++ ) {
		// LEVEL 
		if ( gKillCount[id] == gUchihaLevel[iLevel] ) { 
			gUchihaCurrentLevel[id] = iLevel + 1
			
			// For the Uchiha lvl 1 - Amaterasu
			gAmaterasu_shots[id] += get_pcvar_num(gPcvar_Ama_ammo)
			 
			if ( gUchihaCurrentLevel[id] == 1 ) {
				sh_chat_message(id, gHeroID, "Amaterasu Habilitado! Activalo con el Click Derecho con la Faka.")
				break;
			}
			
			// For the Uchiha lvl 2 - Chidori
			chidori_shots[id] += get_pcvar_num(gPcvarChi_Ammo)
			
			if ( gUchihaCurrentLevel[id] == 2 ) {
				sh_chat_message(id, gHeroID, "Chidori Habilitado! Activalo con el Click Izquierdo con la Faka.")
				break;
			}
			
			// For the Uchiha lvl 3 - Susanoo
			create_susanoo(id)
			susano_boost(id)
			
			if ( gUchihaCurrentLevel[id] == 3 ) {
				sh_chat_message(id, gHeroID, "Invocaste tu Propio Susanoo!")
				break;
			}
			
			// For the Uchiha lvl 4 - Tsukuyomi ?°
			sh_chat_message(id, gHeroID, "Estas Activando el Tsukuyomi Infinito.")
			active_tsukuyomi(id)
		}
	}
} 
//----------------------------------------------------------------------------------------
//					Amaterasu 					//
//----------------------------------------------------------------------------------------
public Ham_Weapon_Attack2(weaponent)			// Amaterasu in Right Click with Knife.
{
	new id = get_pdata_cbase(weaponent, 41, 4)
	if ( !is_user_alive(id) || !gHasUchihaPower[id] ) return HAM_IGNORED;
	
	// Para que solo lo use cuando tenga amaterasu shots habilitado
	if ( gAmaterasu_shots[id] <= 0 ) return HAM_IGNORED;
	
	// Amaterasu in Right Click with Knife.
	if ( gUchihaCurrentLevel[id] >= 1 ) {	// && gAmaterasu_shots[id] >= 0 
		amaterasu_shot(id)
		sh_screen_fade(id, 2.5, 2.5, 255, 10, 10, 50) 
		gAmaterasu_shots[id]--
	}
	 
	return HAM_IGNORED;
}

public amaterasu_shot(id)
{
	emit_sound(id, CHAN_STATIC, gAmaterasu_Sound, 1.0, ATTN_NORM, 0, PITCH_NORM)
	
	new Float:Origin[3], Float:Velocity[3], Float:vAngle[3]

	entity_get_vector(id, EV_VEC_origin , Origin)
	entity_get_vector(id, EV_VEC_v_angle, vAngle)

	new amaterasu = create_entity("info_target")
	// set class name and model
	entity_set_string(amaterasu, EV_SZ_classname, gAmaterasu_Ent_Name)
	entity_set_model(amaterasu, gAmaterasu_Ent_Model)

	entity_set_size(amaterasu, Float:{-2.5, -2.5, -1.5}, Float:{2.5, 2.5, 1.5})	// tamaÒo?
	entity_set_origin(amaterasu, Origin)
	entity_set_vector(amaterasu, EV_VEC_angles, vAngle)	// donde se pone la entidad con vectores vorigin
	
	// types, n owner
	entity_set_int(amaterasu, EV_INT_solid, 2)	// solid
	entity_set_int(amaterasu, EV_INT_movetype, 5)	// don't move
	entity_set_edict(amaterasu, EV_ENT_owner, id)	// para declarar el dueÒo de la entidad
	
	//thanx to vittu for this part.
	entity_set_int(amaterasu, EV_INT_rendermode, 5)
	entity_set_float(amaterasu, EV_FL_renderamt, 200.0)
	entity_set_float(amaterasu, EV_FL_scale, 1.00)	// para poner el tamaÒo del sprite x2.0 es el doble
	
	velocity_by_aim(id, 650, Velocity)	// para poner en movimiento la entidad con velocidad
	entity_set_vector(amaterasu, EV_VEC_velocity ,Velocity)	// mover la entidad 
	
	set_task(10.0, "remove_amaterasu", id)
		
	/* ant code maybe ver otro dÌa
	// Esto es para lograr la animacion del sprite - tiene que ir antes del movetype y solid_
	entity_set_float(amaterasu, EV_FL_animtime, 1.0) 		// I'm not entirely sure about this, but I think it is the time in which the sprite will animate.
	entity_set_float(amaterasu, EV_FL_framerate, 10.0)		// Frames per second.
	entity_set_int(amaterasu, EV_INT_spawnflags, SF_SPRITE_STARTON) 	// Essential if the animation is playing, I think.
	dllfunc( DLLFunc_Spawn, amaterasu ) 
	
	entity_set_int(amaterasu, EV_INT_rendermode, kRenderFxNoDissipation);		// necesario para quitar el fondo negro
	set_rendering(amaterasu, kRenderFxNoDissipation, _, _, _, kRenderGlow, 255) 	// put this to remove the black background of the sprite
	
	
	 // REVISAR
	if(burndecals != 0) {
		// TE_GUNSHOTDECAL
		message_begin(MSG_BROADCAST,SVC_TEMPENTITY)
		write_byte(109) 		// decal and ricochet sound
		write_coord(aimvec[0]) 		// pos
		write_coord(aimvec[1])
		write_coord(aimvec[2])
		write_short(0) 			// I have no idea what thats supposed to be
		write_byte(random_num(28, 30)) 	// decal
		message_end()
	} */ 
}

public remove_amaterasu(id)
{
	new ent = SH_MAXSLOTS+1;
	while ( (ent = find_ent_by_owner(ent, gAmaterasu_Ent_Name, id) ) > 0 ) { 
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
	}
}

public on_fire(args[])
{
	new victim = args[0]
	new id = args[1]
	
	if( !is_user_connected(victim) || !is_user_alive(victim) ) {
		gIsBurning[victim] = false
		// generic print chat
		static attackerName[32] 
		get_user_name(id, attackerName, 31)
		sh_chat_message(victim, -1, "[%s] Te quemo con su %s.", attackerName, gAmaterasu_Ent_Name)
		return
	}
	
	gIsBurning[victim] = true
	
	if ( !gIsBurning[victim] || !sh_is_inround() ) return 
	
	new rx, ry, rz, forigin[3]
	rx = random_num(-30, 30)
	ry = random_num(-30, 30)
	rz = random_num(-30, 30)
	get_user_origin(victim, forigin)

	//TE_SPRITE - additive sprite, plays 1 cycle
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(17)
	write_coord(forigin[0]+rx)	// coord, coord, coord (position)
	write_coord(forigin[1]+ry)
	write_coord(forigin[2]+10+rz)
	write_short(gSpriteAmaterasu)	// short (sprite index)
	write_byte(30)			// byte (scale in 0.1's)
	write_byte(200)			// byte (brightness)
	message_end()

	//Smoke
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(5)
	write_coord(forigin[0]+(rx*2))	// coord, coord, coord (position)
	write_coord(forigin[1]+(ry*2))
	write_coord(forigin[2]+100+(rz*2))
	write_short(gSpriteSmoke)	// short (sprite index)
	write_byte(60)			// byte (scale in 0.1's)
	write_byte(15)			// byte (framerate)
	message_end()
	
	// set damage 
	static damage
	damage = get_pcvar_num(gPcvar_Ama_Dmg)	
	sh_extra_damage(victim, id, damage, gAmaterasu_Ent_Name)
}
//----------------------------------------------------------------------------------------
//			Amaterasu and	Chidori 					//
//----------------------------------------------------------------------------------------
public amaterasu_chidori_touch(ent, victim)
{
	if ( !pev_valid(ent) || !pev_valid(victim) ) return	// || !is_user_alive(victim) 
	// if ( !is_user_connected(victim) || !is_user_alive(victim) ) return
	
	static classname[32]
	entity_get_string(ent, EV_SZ_classname, classname, 31)
	if ( equal(classname, gAmaterasu_Ent_Name) ) {
		static iOwner
		iOwner = entity_get_edict(ent, EV_ENT_owner)
		if ( is_user_connected(iOwner) && get_user_team(iOwner) != get_user_team(victim) ) {
			static args[3]
			args[0] = victim
			args[1] = iOwner
			set_task(0.3, "on_fire", 451, args, 3, "a", gPcvar_Ama_Burn_Num)
			// This is for Amaterasu still on the ground after touched
			remove_amaterasu(iOwner)
			// remove_entity(ent);
		} 
	}
	
	// if ( !pev_valid(ent) || !pev_valid(victim) ) return
	// if ( !is_user_connected(victim) || !is_user_alive(victim) ) return
	else if ( equal(classname, "player") ) {
		if (  gHasUchihaPower[ent] && touchChidoriPower[ent] && get_user_team(ent) != get_user_team(victim) ) {
			// Damage
			sh_extra_damage(victim, ent, gPcvarChi_Dmg, "Por Chidori") 	// , 0, SH_DMG_KILL) if u wanna killdmg uncomment
		}
	}
}
//----------------------------------------------------------------------------------------
//					Chidori 					//
//----------------------------------------------------------------------------------------
public Ham_Weapon_Attack1(weaponent)			// Chidori in Left Click with Knife.
{
	new id = get_pdata_cbase(weaponent, 41, 4)
	if ( !is_user_alive(id) || !gHasUchihaPower[id] ) return HAM_IGNORED;
	
	// Para que sepa que usas el poder y va restando tenes 2 al nivel 2 y obtenes 2 cada nivel
	if ( chidori_shots[id] <= 0 ) return HAM_IGNORED;
	
	// Chidori in Left Click with Knife.
	if ( gUchihaCurrentLevel[id] >= 2 ) {
		//Switch to Nade - Chidori
		sh_give_weapon(id, CSW_FLASHBANG, true)
		engclient_cmd(id, "weapon_flashbang")
		chidori(id)
		chidori_shots[id]--
	}
	
	return HAM_IGNORED;
}

public curweapon_chidori_sunasoo(id)
{
	if ( !gHasUchihaPower[id] ) return	 // || !is_user_alive(id) ) return
	
	// this is for chidori
	new wpnid = get_user_weapon(id)
	if ( wpnid == CSW_FLASHBANG && touchChidoriPower[id] ) switch_model(id)
	
	// this is for susano for dont loose the speed 
	if ( g_prevWeapon[id] != wpnid && gUchihaCurrentLevel[id] >= 3  ) {
		set_user_maxspeed( id, get_pcvar_float(PcvarSusanoSpeed) );
		g_prevWeapon[id] = wpnid
	}
}

switch_model(id) 
	if (get_user_weapon(id) == CSW_FLASHBANG) entity_set_string(id, EV_SZ_viewmodel, gChidori_model)

public chidori(id)
{
	// Stop the sound
	new sndStop=(2<<5)
	emit_sound(id, CHAN_STATIC, "shmod/chidorisas.wav", 1.0, ATTN_NORM, sndStop, PITCH_NORM)
	set_task(0.1, "chidori_spark", id, "", 0, "a", 8) 	// 10 = 1 seconds
	
	// Esto trabaja asi cuanto mayor el segundo termino de vel_by_aim, mayor el dash que dara
	static Float:velocity[3]
	velocity_by_aim(id, 1500, velocity)		// def = 1500 velocity en vector for kill with chidori 
	set_pev(id, pev_velocity, velocity) 		// velocity[0] = 1000.0 X //velocity[1] = 1000.0 Y //velocity[2] = 100.0 Z
	
	// Para que se habilite el daÒo del touch
	touchChidoriPower[id] = true			// For touch damage to be enabled
	
	sh_set_rendering(id, 141, 143, 144, 16, kRenderFxGlowShell)	// Esto es para darle un glow
	
	// Esto es para que se quite el touck kill/damage despues del salto masomenos
	set_task(0.6, "reset_chidori", id)		//	def = 1.0
}

public reset_chidori(id) 
{
	touchChidoriPower[id] = false
	sh_set_rendering(id)
	sh_drop_weapon(id, CSW_FLASHBANG, true)
	engclient_cmd(id, "weapon_knife")
} 
	
public chidori_spark(id)
{	
	new rx, ry, origin[3]
	rx = random_num(-10, 10)
	ry = random_num(-10, 10)
	// rz = random_num(-15, 15)
	get_user_origin(id, origin)

	//TE_SPRITE - additive sprite, plays 1 cycle
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(17)
	write_coord(origin[0]+rx)	// coord, coord, coord (position)
	write_coord(origin[1]+ry)
	write_coord(origin[2]+10) //+rz)
	write_short(gSpriteSpark)	// short (sprite index)
	write_byte(2)			// byte (scale in 0.1's)
	write_byte(250)			// byte (brightness)
	message_end()
}
//----------------------------------------------------------------------------------------
//					Susanoo						//
//----------------------------------------------------------------------------------------
public susano_boost(id)
{
	if ( !gHasUchihaPower[id] || !is_user_alive(id) ) return
	
	if ( gUchihaCurrentLevel[id] >= 3 ) {
		// Set stats boost of Susanoo
		set_user_maxspeed( id, get_pcvar_float(PcvarSusanoSpeed) );
		new MaxHP	= get_pcvar_num(PcvarHPSusano)	// def 1800 
		set_user_health(id, MaxHP)
		set_user_armor(id, MaxHP)

		set_task(1.0, "susano_loop", id, _, _, "b") 	// HEAL LOOP
	}
}

public susano_loop(id) 
{
	if ( is_user_alive(id) && gUchihaCurrentLevel[id] >= 3 ) {	
		new MaxHP	= get_pcvar_num(PcvarHPSusano)	// def 1800
		new HealPoints  	= get_pcvar_num(PcvarHealPoints) 
		sh_add_hp(id, HealPoints, MaxHP)
	}
}

public Fw_TakeDamage_Pre(iVictim, iInflictor, iAttacker, Float:fDamage) // , bitsDamageType
{
	// return ham_ignored es como el plugin_continue
	if ( ! (1 <= iAttacker <= SH_MAXSLOTS) ) return HAM_IGNORED;
	if ( ! (1 <= iVictim <= SH_MAXSLOTS) ) return HAM_IGNORED;
	
	if ( gUchihaCurrentLevel[iVictim] < 3 || !gHasUchihaPower[iVictim] ) return HAM_IGNORED
	if ( !is_user_alive(iVictim) || !is_user_alive(iAttacker)) return HAM_IGNORED
	
 
	// obtengo el arma, y tambien verifico que el knife sea del atacante solo con el knife porque sino podria
	// bugearlo con las he grenade por eso la verificacion atacker== inflictor
	new randnum = random_num(1, 100)
	new susanochancheK = get_pcvar_num(pcvarPercentKnife)
	
	if ( get_user_weapon(iAttacker) == CSW_KNIFE && iAttacker == iInflictor && susanochancheK >= randnum ) {
		
		SetHamParamFloat(4, fDamage / 2.0)
		
		set_hudmessage(0, 100, 200, 0.05, 0.60, 1, 0.1, 2.0, 0.1, 0.1, 3)
		show_hudmessage(iVictim, "[%s] Blockeaste un Ataque con Susanoo!", gHeroName)
		 
		return HAM_HANDLED
	}
     
	return HAM_IGNORED
}

public create_susanoo(id)
{
	// put glow in the player
	sh_set_rendering(id, 154, 0, 210, 16, kRenderFxGlowShell)
	set_task(5.0, "susanoo_unglow", id)
	
	new susanoo = create_entity("info_target")
	
	if ( !pev_valid(susanoo) ) return
    
	set_pev(susanoo, pev_classname, gSusanoo_name)		// name of ent
	entity_set_model(susanoo, gSusanoo_model)		// model
	
	set_pev(susanoo, pev_solid, SOLID_TRIGGER); 		// touch on edge, block  SOLID_BBOX    
	set_pev(susanoo, pev_movetype, MOVETYPE_FOLLOW)		// follor player id MOVETYPE_FOLLOW
	set_pev(susanoo, pev_aiment, id)			// owner ? 
	set_pev(susanoo, pev_owner, id)				// for set owner	
	set_pev(susanoo, pev_framerate, 1.0)			// This is for animation? 
	set_pev(susanoo, pev_animtime, get_gametime() )		// This is for animation? 
	set_pev(susanoo, pev_sequence, 0)			// What is sequence?
	// Glow ?
	new Float:glowColor[3] = {154.0, 0.0, 210.0}
	set_pev(susanoo, pev_renderfx, kRenderFxGlowShell)	
	set_pev(susanoo, pev_rendercolor, glowColor)	
	set_pev(susanoo, pev_rendermode, kRenderTransAlpha)	
	set_pev(susanoo, pev_renderamt, 40.0)	// def 40
	// set_rendering(susanoo, kRenderFxGlowShell, 154, 0, 210, kRenderNormal, 25); // I use this for glow entity , Es otra forma pero recomiendo la anterior
	
	fm_set_entity_visibility(susanoo, 1)
	
	iUserSusano[id] = susanoo 
	
	// Effect Susanoo
	new parm[2]
	parm[0] = id 
	parm[1] = 40
	susanoo_effect(parm) 
	set_task(0.1, "susanoo_effect", 0, parm, 2, "a", 200)
}

public remove_susanoo(id)
{
	new ent = SH_MAXSLOTS+1;
	while( (ent = find_ent_by_owner(ent, gSusanoo_name, id)) > 0) { 
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
		iUserSusano[id] = -1;
	}
	 
	/*
	new susanoo = iUserSusano[id]
	if(susanoo != -1 && pev_valid(susanoo)) {
		static szClassname[32];
		pev(susanoo, pev_classname, szClassname, 31);
		if ( equal(szClassname, gSusanoo_name) ) {
			set_pev(susanoo, pev_flags, FL_KILLME)
			dllfunc(DLLFunc_Think, susanoo)
			iUserSusano[id] = -1;
		}
	} */
}

public susanoo_unglow(id) sh_set_rendering(id)

// called to make ent invisible or render it to 100
stock fm_set_entity_visibility(index, visible = 1)
{
	if( !visible ) {
		fm_set_rendering(index, kRenderFxGlowShell, kRenderNormal, 0)
		return;
	}
	
	fm_set_rendering(index, kRenderFxGlowShell, kRenderNormal, 100 )
}

stock fm_set_rendering(entity, fx = kRenderFxNone, kRender, amount = 16) 
{
	set_pev(entity, pev_renderfx, fx)
	set_pev(entity, pev_rendermode, kRender)
	set_pev(entity, pev_renderamt, float(amount))
}
//--------- Thanx to vittu for this code.
public susanoo_effect(parm[])
{
	if ( !sh_is_inround() ) return
	
	new id = parm[0]
	if ( !is_user_alive(id) ) return
 
	new Size = parm[1]
	new players[SH_MAXSLOTS], pnum
	new idOthers, Origin[3]

	get_players(players, pnum, "a")
	// Show a powerup to all alive players except the one being powered up.
	for (new i = 0; i < pnum; i++) {
		idOthers = players[i]
		if ( idOthers == id ) continue		// con esto no dejo que vea su sprite
		// if ( !is_user_alive(idOthers) ) continue					// con esto si lo ve xd
		get_user_origin(id, Origin)

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteAmaterasu)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0]+5) // center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteAmaterasu)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0]-5)	// center position
		write_coord(Origin[1])
		write_coord(Origin[2]+20)
		write_short(gSpriteAmaterasu)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1]+5)
		write_coord(Origin[2]+10)
		write_short(gSpriteAmaterasu)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()

		// power up sprite - additive sprite, plays 1 cycle
		message_begin(MSG_ONE, SVC_TEMPENTITY, Origin, idOthers)
		write_byte(17)			// TE_SPRITE
		write_coord(Origin[0])	// center position
		write_coord(Origin[1]-5)
		write_coord(Origin[2]+10)
		write_short(gSpriteAmaterasu)	// sprite index
		write_byte(Size)		// scale in 0.1's
		write_byte(50)			// brightness
		message_end()
	}
} 
//----------------------------------------------------------------------------------------
//					Tsukuyomi					//
//----------------------------------------------------------------------------------------
public active_tsukuyomi(id)
{
	if ( !sh_is_inround() ) return
	
	// Timer LOOP_players/id show the huds
	new total_time = start_time_num + get_pcvar_num(pcvarTimeTs)
	new Float: seconds = start_time_float + get_pcvar_float(pcvarTimeTs)
	sh_set_godmode(id, seconds)
	
	new players[SH_MAXSLOTS], pnum, player
	get_players(players, pnum, "a")
	for (new i = 0; i < pnum; i++) {
		player = players[i]
		if ( is_user_alive(player) ) {
			gTimer_Tsuku[player] = total_time
			set_task(1.0, "tsukustart_playerhud", player, "", 0, "b")
		}
	}
}

public tsukustart_playerhud(id)
{
	if ( !sh_is_inround() || gTimer_Tsuku[id] < 0 ) return
	
	if ( gTimer_Tsuku[id] > start_time_num ) {
		set_hudmessage( 50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 4)
		ShowSyncHudMsg( id, HappyHudSync, "El Tsukuyomi Infinito empezar√° en %d segundos.", gTimer_Tsuku[id] - start_time_num )
	}
	else if ( gTimer_Tsuku[id] == start_time_num ) {
		Tsukuyomi(id)
		set_hudmessage( 50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 4)
		ShowSyncHudMsg( id, HappyHudSync, "El Tsukuyomi Infinito terminar√° en %d segundos.", gTimer_Tsuku[id] )
	}
	else {
		set_hudmessage( 50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 4)
		ShowSyncHudMsg( id, HappyHudSync, "El Tsukuyomi Infinito terminar√° en %d segundos.", gTimer_Tsuku[id] )
	}
	
	gTimer_Tsuku[id]--
}

public Tsukuyomi(id)
{
	if ( !sh_is_inround() ) return 
	
	if ( gUchihaCurrentLevel[id] < 3 ) {

		sh_set_stun( id, start_time_float, 1.0)	//stun here, unless we want to pass seconds to the function as well.
		set_user_gravity(id, 4000.0) 
		sh_screen_fade( id, start_time_float, start_time_float, 148, 148, 148, 148 )	//make screen gray
		gInTsukuyomi[id] = true
		 
		// for remove event
		set_task(start_time_float, "tsukuyomi_reset", id) 
	} 
}

public tsukuyomi_reset(id)
{
	gTimer_Tsuku[id] = -1
	gInTsukuyomi[id] = false

	sh_reset_max_speed(id)
	sh_reset_min_gravity(id)

	set_hudmessage(50, 100, 255, -1.0, 0.25, 0, 0.0, 1.0, 0.0, 0.0, 3)
	ShowSyncHudMsg(id, HappyHudSync, "Te liberaste del Genjutsu Tsukuyomi Infinito termin√≥.")
	remove_task(id)
}

public Player_Jump(id)
{
	if( gInTsukuyomi[id] ) return HAM_SUPERCEDE;
	
	return HAM_IGNORED;
}

public tsukuyomi_respawn(parm[])
{
	new victim = parm[0]
	if ( !is_user_connected(victim) || is_user_alive(victim) || !sh_is_inround() ) return
	if ( KillCountTsukuyomi[victim] == get_pcvar_num(pcvarTsukuyomiRespawns) ) return

	emit_sound(victim, CHAN_STATIC, gSoundReBirth, 0.2, ATTN_NORM, 0, PITCH_NORM)

	sh_chat_message(victim, -1, "El Tsukuyomi te revivi√≥ para matarte otra vez en su Genjutsu.")

	// Double spawn prevents the no HUD glitch
	// This should eventually be changed to use a better method
	spawn(victim) 
	spawn(victim)  
	//ExecuteHamB(Ham_CS_RoundRespawn, id)		// Use this no for bots 
	KillCountTsukuyomi[victim]++

	emit_sound(victim, CHAN_STATIC, "ambience/3dmeagle.wav", 0.6, ATTN_NORM, 0, PITCH_NORM)
	sh_screen_fade( victim, start_time_float, start_time_float, 148, 148, 148, 148 )	//make screen gray
	sh_set_rendering(victim, 141, 143, 144, 16, kRenderFxGlowShell)	// Glow
	set_task(1.0, "tsukuyomi_unglow2", victim) 			// Unglow
	set_user_health(victim, 500)					// Set HP after respawn
	tsukuyomi_teleport(victim)
 
	// If player is stuck, try to unstuck him
	new hulltype = (pev(victim, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN
	if ( !sh_hull_vacant(victim, gFVecOrigin[victim], hulltype) ) {
		unstuck(victim, hulltype)
	} 
}

public tsukuyomi_teleport(id)
{
	emit_sound(id, CHAN_STATIC, gSoundEagle, 0.6, ATTN_NORM, 0, PITCH_NORM)

	sh_set_rendering(id, 248, 20, 25, 16, kRenderFxGlowShell)
	set_task(3.0, "susanoo_unglow", id)

	// Thanks to Connor for duck and angles part
	if ( is_user_alive(id) && gFVecOrigin[id][0] ) {
		set_pev(id, pev_flags, pev(id, pev_flags) | FL_DUCKING)
		engfunc(EngFunc_SetSize, id, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX)
		engfunc(EngFunc_SetOrigin, id, gFVecOrigin[id])
		set_pev(id, pev_view_ofs, VEC_DUCK_VIEW)

		set_pev(id, pev_angles, gFVecAngles[id])
		set_pev(id, pev_v_angle, VEC_NULL)
		set_pev(id, pev_fixangle, 1)
	}
}
//----------------------------------------------------------------------------------------------
//Thank you from AMXX NS unstuck plugin
unstuck(id, hulltype)
{
	new Float:new_origin[3], distance, i
	distance = 32

	while ( distance < 1000 ) {	// 1000 is just incase, should never get anywhere near that
		for ( i = 0; i < 128; i++ ) {
			new_origin[0] = random_float(gFVecOrigin[id][0] - distance, gFVecOrigin[id][0] + distance)
			new_origin[1] = random_float(gFVecOrigin[id][1] - distance, gFVecOrigin[id][1] + distance)
			new_origin[2] = random_float(gFVecOrigin[id][2] - distance, gFVecOrigin[id][2] + distance)

			if ( fm_trace_hull(new_origin, hulltype, id) == 0 ) {
				engfunc(EngFunc_SetOrigin, id, new_origin)
				return
			}
		}
		distance += 32
	}
}
//----------------------------------------------------------------------------------------------
//Stock from fakemeta_util.inc
stock fm_trace_hull(const Float:origin[3], hull, ignoredent = 0, ignoremonsters = 0) {
	new result = 0;
	engfunc(EngFunc_TraceHull, origin, origin, ignoremonsters, hull, ignoredent > 0 ? ignoredent : 0, 0);

	if (get_tr2(0, TR_StartSolid))
		result += 1;
	if (get_tr2(0, TR_AllSolid))
		result += 2;
	if (!get_tr2(0, TR_InOpen))
		result += 4;

	return result;
}
//----------------------------------------------------------------------------------------
//			Client_disconnected / Admin Check				//
//----------------------------------------------------------------------------------------
public client_disconnected(id)
{
	// This is From Amaterasu	// stupid check but lets see
	if(id <= 0 || id > SH_MAXSLOTS) return
	
	// Yeah don't want any left over residuals
	remove_task(id)
	remove_susanoo(id)
	remove_amaterasu(id)
	tsukuyomi_reset(id)
}
//----------------------------------------------------------------------------------------
#if SEND_COOLDOWN
public sendUchihaLevel(id)
{
	new cooldown
	if ( gUchihaCurrentLevel[id] > 0 )
		cooldown = gUchihaCurrentLevel[id] 
	else
		cooldown = -1
	return cooldown
}

public sendUchihaChidori(id)
{
	new cooldown
	if ( chidori_shots[id] > 0 )
		cooldown = chidori_shots[id]
	else
		cooldown = -1
	return cooldown
} 

public sendUchihaAmaterasu(id)
{
	new cooldown
	if ( gAmaterasu_shots[id] > 0 )
		cooldown = gAmaterasu_shots[id]
	else
		cooldown = -1
	return cooldown
}
#endif
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1030\\ f0\\ fs16 \n\\ par }
*/
