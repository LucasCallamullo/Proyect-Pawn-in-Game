/*
// Shaco
shaco_level 6
shaco_cooldown 21	// cooldown
shaco_stuntime 1.5	// tiempo de stun
shaco_radius 450	// radio al que se activa


*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <amxmod>
#include <superheromod>
#include <Vexd_Utilities> 

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Shaco"
new bool:gHasShaco[SH_MAXSLOTS+1]

new g_SavedOrigin[SH_MAXSLOTS+1][3], g_LastPosition[SH_MAXSLOTS+1][3]
new bool:gPauseEntity[999]
new Float:gShacoBoxSpeed
new PcvarSpeed, gSpriteTrail, gPcvarCooldown, gPcvarStun, gPcvarRadius

#if SEND_COOLDOWN
	new Float:ShacoUsedTime[SH_MAXSLOTS+1]
#endif
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Shaco", "1.1", "Lucas Cab Arje")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvar_lev 	= register_cvar("shaco_level", "6")		// LEvel
	gPcvarCooldown	= register_cvar("shaco_cooldown", "5")		// Cooldown
	gPcvarStun	= register_cvar("shaco_stuntime", "2")		// Stun time
	gPcvarRadius	= register_cvar("shaco_radius", "500")		//Radio de activacion

	// Esta es la velocidad de la entidad no tocar
	PcvarSpeed 	= register_cvar("shaco_speed", "500") 

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvar_lev);
	sh_set_hero_info(gHeroID, "Pone Cajas Trampa!", "Tus trampas se activarán cuando alguien pase cerca y te teletransportará al lugar, escondelas! - Pone en say /bind para aprender a bindear.");
	sh_set_hero_bind(gHeroID);  

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// FAKEMETA FORWARD
	register_forward(FM_Think, "fw_entity_think", 0)

	// ROUND START
	register_logevent("round_start", 2, "1=Round_Start")
}

public plugin_precache()
{
	precache_model("models/shmod/shacobox.mdl")
	gSpriteTrail = precache_model("sprites/smoke.spr")
	precache_sound("shmod/shacobox.wav")
}
//------------------------------------------------------------------------------------------------
//				SH INIT and KEY							//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode) {
		case SH_HERO_ADD: {
			gHasShaco[id] = true
			gPlayerInCooldown[id] = false
		}
		case SH_HERO_DROP: {
			gHasShaco[id] = false;
		}
	} 
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasShaco[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] ) {
			playSoundDenySelect(id)
			return;	
		}
		
		remove_shaco(id)		// This is for only have one box at the time
		
		static aimvec[3]		// Get position from eyes
		get_user_origin(id, aimvec, 3)	// Get position from eyes
		ShacoBox_create(id, aimvec)  
		
		new Float:seconds = get_pcvar_float(gPcvarCooldown)
		if ( seconds > 0.0 ) {
			sh_set_cooldown(id, seconds)
			#if SEND_COOLDOWN
				ShacoUsedTime[id] = get_gametime()
			#endif
		}
	}
	
	// return PLUGIN_HANDLED
}
#if SEND_COOLDOWN
public sendShacoCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(gPcvarCooldown) - get_gametime() + ShacoUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//------------------------------------------------------------------------------------------------
//				Spawn y demas							//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if (gHasShaco[id] && is_user_alive(id) ) {
		gPlayerUltimateUsed[id]=false
		remove_shaco(id); 
	}
}

public ShacoBox_create(id, aimvec[3])
{ 	
	new Float:vOrigin[3]
	vOrigin[0] += float( aimvec[0] )
	vOrigin[1] += float( aimvec[1] )
	vOrigin[2] += float( aimvec[2] + 5 )
	
	// new pCreated[SH_MAXSLOTS+1]
	
	/* new entity
	while ((entity = find_ent_by_class(entity, "Doggy")) > 0) {
	    entity_set_int(entity, EV_INT_flags, FL_KILLME)
	    entity_set_int(entity, EV_INT_effects, EF_NODRAW)
	    entity_set_int(entity, EV_INT_solid, SOLID_NOT)
	} */
		
	/* if( pev_valid(pCreated [id]) ) {
		engfunc(EngFunc_SetOrigin, pCreated[id], vOrigin) 
		return;
	} */
	
	new ShacoBox = create_entity("info_target")
	entity_set_string(ShacoBox, EV_SZ_classname, "ShacoBox")
	entity_set_model(ShacoBox, "models/shmod/shacobox.mdl")	
	entity_set_size(ShacoBox, Float:{-2.5, -2.5, -1.5}, Float:{2.5, 2.5, 1.5})
	entity_set_edict(ShacoBox, EV_ENT_owner, id)
	entity_set_int(ShacoBox, EV_INT_solid, SOLID_TRIGGER)
	entity_set_int(ShacoBox, EV_INT_movetype, MOVETYPE_FLY)
	entity_set_vector(ShacoBox, EV_VEC_origin, vOrigin)
	
	// Save users origin on death
	get_user_origin(id, g_SavedOrigin[id])	
	g_SavedOrigin[id][0] = aimvec[0]
	g_SavedOrigin[id][1] = aimvec[1]
	g_SavedOrigin[id][2] = aimvec[2] + 50		//def 8 
	
	// Set speed here since it gets called so much
	gShacoBoxSpeed = get_pcvar_float(PcvarSpeed)
	if ( gShacoBoxSpeed <= 0.0 ) gShacoBoxSpeed = 1.0 

	new parm[3]	//def 3
	parm[0] = ShacoBox
	parm[1] = id 
	
	set_task(1.0, "find_target", 0, parm, 3, "b")
	
	new classname[32]
	entity_get_string(ShacoBox, EV_SZ_classname, classname, 31)
	if ( equal(classname, "ShacoBox") ) {
		gPauseEntity[ShacoBox] = true
	}  
}

public find_target(parm[])
{
	new ShacoBox = parm[0]
	new id = parm[1]

	if ( is_valid_ent(ShacoBox) ) {
		
		new classname[32]
		entity_get_string(ShacoBox, EV_SZ_classname, classname, 31)
		if ( equal(classname, "ShacoBox") ) {
			
			gPauseEntity[ShacoBox] = true
			new shortestDistance = get_pcvar_num(gPcvarRadius)	 // def 9999 - 250 - 500
			new nearestPlayer = 0 
			new distance, team[33], rgb[3], players[SH_MAXSLOTS], pnum
			
			// Find all alive enemies and set trail color
			if ( !(id <= id <= SH_MAXSLOTS) || !is_user_alive(id) ) return
			
			get_user_team(id, team, 32) 
			if ( cs_get_user_team(id) == CS_TEAM_CT ) {
				get_players(players, pnum, "ae", "TERRORIST")
				rgb = {50, 50, 175}
				}
			else 	{
				get_players(players, pnum, "ae", "CT")
				rgb = {175, 50, 50}
			}

			// Find the closest enemy
			for (new i = 0; i < pnum; i++) {
				if ( !is_user_alive(players[i]) ) continue

				distance =  get_entity_distance(players[i], ShacoBox)

				if ( distance <= shortestDistance ) {
					shortestDistance = distance
					nearestPlayer = players[i]
				}
			}
 
			// Make the nade seek that enemy if one exists
			if ( nearestPlayer > 0 ) {
				// Trail on grenade
				message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
				write_byte(22)				// TE_BEAMFOLLOW
				write_short(ShacoBox)		// entity:attachment to follow
				write_short(gSpriteTrail)	// sprite index
				write_byte(10)		// life in 0.1's
				write_byte(3)		// line width in 0.1's
				write_byte(rgb[0])	// r
				write_byte(rgb[1])	// g
				write_byte(rgb[2])	// b
				switch(random_num(0,2)) {
					case 0:write_byte(64)	// brightness
					case 1:write_byte(128)
					case 2:write_byte(192)
				} 
				message_end()

				parm[2] = nearestPlayer
				set_task(0.1, "seek_target", ShacoBox+1000, parm, 3, "b")
			}
		}
	}
}

public seek_target(parm[])
{
	new ShacoBox = parm[0]
	new targetn = parm[2]

	if ( !is_valid_ent(ShacoBox) ) {
		remove_task(ShacoBox+1000)
		return 
	}
 
	if ( is_user_alive(targetn) ) {
		entity_set_follow(ShacoBox, targetn) 
		} 
	else 	{
		// Remove the seek loop
		remove_task(ShacoBox+1000)

		// Stop the Trail
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(99)		//TE_KILLBEAM
		write_short(ShacoBox)	// entity
		message_end()

		// Find a new player to seek
		set_task(0.1, "find_target", 0, parm, 3)
	}
}

public pfn_touch(ptr, ptd) 
{
	if(!is_valid_ent(ptd) || !is_valid_ent(ptr)) return PLUGIN_CONTINUE		
	if(!is_user_connected(ptd) || !is_user_alive(ptd)) return PLUGIN_CONTINUE	
		
	new classname[32]
	entity_get_string(ptr, EV_SZ_classname, classname, 31)
	if ( equal(classname, "ShacoBox") ) {
		static id;
		id = entity_get_edict(ptr, EV_ENT_owner);
		if ( gHasShaco[id] && get_user_team(id) != get_user_team(ptd) ) {
			sh_set_stun(ptd, get_pcvar_float(gPcvarStun), 1.0);
			ShacoBox_teleport(id);
			remove_entity(ptr);
		}	
	}
	
	return PLUGIN_CONTINUE 
}

public fw_entity_think(ent)
{
	if ( ent <= SH_MAXSLOTS || ent > sizeof(gPauseEntity)-1 ) return FMRES_IGNORED

	if ( gPauseEntity[ent] ) {
		new Float:nextThink = entity_get_float(ent, EV_FL_nextthink)
		set_pev(ent, pev_nextthink, nextThink + 0.1)
		return FMRES_SUPERCEDE
	}

	return FMRES_IGNORED
} 

public round_start()
{
	// Reset any paused entity ids just in case
	for(new i = SH_MAXSLOTS+1; i < sizeof(gPauseEntity)-1; i++) {
		gPauseEntity[i] = false
	}
} 

stock entity_set_follow(entity, target)
{
	if ( !is_valid_ent(entity) || !is_user_alive(target) ) return 0

	new Float:fl_Origin[3], Float:fl_EntOrigin[3]
	entity_get_vector(target, EV_VEC_origin, fl_Origin)
	entity_get_vector(entity, EV_VEC_origin, fl_EntOrigin)

	new Float:fl_InvTime = (gShacoBoxSpeed / vector_distance(fl_Origin, fl_EntOrigin))

	new Float:fl_Distance[3]
	fl_Distance[0] = fl_Origin[0] - fl_EntOrigin[0]
	fl_Distance[1] = fl_Origin[1] - fl_EntOrigin[1]
	fl_Distance[2] = fl_Origin[2] - fl_EntOrigin[2]

	new Float:fl_Velocity[3]
	fl_Velocity[0] = fl_Distance[0] * fl_InvTime
	fl_Velocity[1] = fl_Distance[1] * fl_InvTime
	fl_Velocity[2] = fl_Distance[2] * fl_InvTime

	entity_set_vector(entity, EV_VEC_velocity, fl_Velocity)

	new Float:fl_NewAngle[3]
	vector_to_angle(fl_Velocity, fl_NewAngle)
	entity_set_vector(entity, EV_VEC_angles, fl_NewAngle)

	return 1
}
//----------------------------------------------------------------------------------------------
// 			Teleport - Demas
//----------------------------------------------------------------------------------------------
public ShacoBox_teleport(id)
{
	emit_sound(id, CHAN_STATIC, "shmod/shacobox.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)
	// sh_set_godmode(id, 1.0)
	set_user_rendering(id, kRenderFxGlowShell, 10, 10, 10, kRenderTransAlpha, 20)
	// Teleport the player
	set_user_origin(id, g_SavedOrigin[id])

	// Teleport Effects
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(11)				// TE_TELEPORT
	write_coord(g_SavedOrigin[id][0])	// start position
	write_coord(g_SavedOrigin[id][1])
	write_coord(g_SavedOrigin[id][2])
	message_end()

	positionChangeTimer(id)
	
	set_task(1.0, "unsetrendering", id)
}

public positionChangeTimer(id)
{
	if ( !is_user_alive(id) ) return

	get_user_origin(id, g_LastPosition[id])

	new Float:velocity[3]
	Entvars_Get_Vector(id, EV_VEC_velocity, velocity)

	if ( velocity[0]==0.0 && velocity[1]==0.0 ) {
		// Force a Move (small jump)
		velocity[0] += 20.0
		velocity[2] += 100.0
		Entvars_Set_Vector(id, EV_VEC_velocity, velocity)
	}
}

public unsetrendering(id)
	set_user_rendering(id)
	
public remove_shaco(id)
{
	
	new ent = 33;
    
	while((ent = find_ent_by_class(ent, "ShacoBox")) != 0) {
		if( entity_get_edict(ent, EV_ENT_owner) != id )
			continue;
            
		remove_entity(ent);
	}
	
	/* if ( gHasShaco[id] && is_user_alive(id) ) {
		new ShacoBox = find_ent_by_class(-1, "ShacoBox")
		while(ShacoBox) {
			remove_entity(ShacoBox)
			ShacoBox = find_ent_by_class(ShacoBox, "ShacoBox") 
		}
	} */
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1030\\ f0\\ fs16 \n\\ par }
*/
