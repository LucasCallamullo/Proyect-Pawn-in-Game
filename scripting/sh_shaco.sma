/*
// Shaco
shaco_level 6
shaco_cooldown 21	// cooldown
shaco_stuntime 1.5	// tiempo de stun
shaco_radius 450	// radio al que se activa


*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Shaco"
new bool:gHasShaco[SH_MAXSLOTS+1]

new bool:gPauseEntity[999]
new Float:gShacoBoxSpeed
new PcvarSpeed, gSpriteTrail, gPcvarCooldown, gPcvarStun, gPcvarRadius

// this for unstuck
new Float:gFVecOrigin[SH_MAXSLOTS+1][3]
new Float:gFVecAngles[SH_MAXSLOTS+1][3]

new const Float:VEC_DUCK_HULL_MIN[3]	= {-16.0, -16.0, -18.0 }
new const Float:VEC_DUCK_HULL_MAX[3]	= { 16.0,  16.0,  32.0 }
new const Float:VEC_DUCK_VIEW[3]	= {  0.0,   0.0,  12.0 }
new const Float:VEC_NULL[3]		= {  0.0,   0.0,   0.0 }

// for the time cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1] 

new const gModel_Shaco[] = "models/shmod/shacobox.mdl"
new const gSound_Shaco[] = "shmod/shacobox.wav"
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Shaco", "1.1", "Lucas Cab Arje")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvar_lev 	= register_cvar("shaco_level", "6")		// LEvel
	gPcvarCooldown	= register_cvar("shaco_cooldown", "5")		// Cooldown
	gPcvarStun	= register_cvar("shaco_stuntime", "2")		// Stun time
	gPcvarRadius	= register_cvar("shaco_radius", "500")		//Radio de activacion

	// Esta es la velocidad de la entidad no tocar
	PcvarSpeed 	= register_cvar("shaco_speed", "500") 

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvar_lev);
	sh_set_hero_info(gHeroID, "Pone Cajas Trampa!", "Tus trampas se activarán cuando alguien pase cerca y te teletransportará al lugar, escondelas! - Pone en say /bind para aprender a bindear.");
	sh_set_hero_bind(gHeroID);  

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// FAKEMETA FORWARD
	register_forward(FM_Think, "fw_entity_think", 0)
}

public plugin_precache()
{
	precache_model(gModel_Shaco)
	precache_sound(gSound_Shaco)
	gSpriteTrail = precache_model("sprites/smoke.spr")
}
//------------------------------------------------------------------------------------------------
//				SH INIT and KEY							//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode) {
		case SH_HERO_ADD: {
			gHasShaco[id] = true
			gPlayerInCooldown[id] = false
		}
		case SH_HERO_DROP: {
			gHasShaco[id] = false;
		}
	} 
	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasShaco[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] ) {
			playSoundDenySelect(id)
			return;	
		}
		
		remove_shaco(id)		// This is for only have one box at the time
		
		static aimvec[3]		// Get position from eyes
		get_user_origin(id, aimvec, 3)	// Get position from eyes
		ShacoBox_create(id, aimvec)  
		
		// set de cooldowns
		new Float:seconds = get_pcvar_float(gPcvarCooldown)
		if ( seconds > 0.0 ) {
			sh_set_cooldown(id, seconds)
			gPcvarRealCD[id] = seconds
		}
	}
	
	// return PLUGIN_HANDLED
}
#if SEND_COOLDOWN
public sendShacoCooldown(id)
{
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id]) 
}
#endif
//------------------------------------------------------------------------------------------------
//					Spawn n Death 						//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasShaco[id] ) {
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	}
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if ( gHasShaco[id] ) {
		gPcvarRealCD[id] = sh_get_cooldown(id)
		remove_shaco(id);
	}
}
//------------------------------------------------------------------------------------------------
//				CREATE N REMOVE ENTITY						//
//------------------------------------------------------------------------------------------------
public ShacoBox_create(id, aimvec[3])
{ 	
	new Float:vOrigin[3]
	vOrigin[0] += float( aimvec[0] )
	vOrigin[1] += float( aimvec[1] )
	vOrigin[2] += float( aimvec[2] + 5 )

	new ShacoBox = create_entity("info_target")
	entity_set_string(ShacoBox, EV_SZ_classname, "ShacoBox")
	entity_set_model(ShacoBox, gModel_Shaco)	
	entity_set_size(ShacoBox, Float:{-2.5, -2.5, -1.5}, Float:{2.5, 2.5, 1.5})
	entity_set_edict(ShacoBox, EV_ENT_owner, id)
	entity_set_int(ShacoBox, EV_INT_solid, SOLID_TRIGGER)
	entity_set_int(ShacoBox, EV_INT_movetype, MOVETYPE_FLY)
	entity_set_vector(ShacoBox, EV_VEC_origin, vOrigin)
	
	 // Save users origin on entity for the tp
	pev(ShacoBox, pev_origin, gFVecOrigin[id])
	pev(ShacoBox, pev_v_angle, gFVecAngles[id]) 
	 	
	// Set speed here since it gets called so much
	gShacoBoxSpeed = get_pcvar_float(PcvarSpeed)
	if ( gShacoBoxSpeed <= 0.0 ) gShacoBoxSpeed = 1.0 

	new parm[3]	//def 3
	parm[0] = ShacoBox
	parm[1] = id 
	
	set_task(1.0, "find_target", 0, parm, 3, "b")
	
	new classname[32]
	entity_get_string(ShacoBox, EV_SZ_classname, classname, 31)
	if ( equal(classname, "ShacoBox") ) {
		gPauseEntity[ShacoBox] = true
	}  
}

public remove_shaco(id)
{
	new ent = SH_MAXSLOTS+1;
	while( (ent = find_ent_by_owner(ent, coronavirus_ent_name, id)) > 0) { 
		set_pev(ent, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, ent);
	}
	
	/* new ent = 33;
	while((ent = find_ent_by_class(ent, "ShacoBox")) != 0) {
		if( entity_get_edict(ent, EV_ENT_owner) != id )
			continue;
		remove_entity(ent);
	}*/
}
//------------------------------------------------------------------------------------------------
//				EFFECT FIND TARGET						//
//------------------------------------------------------------------------------------------------
public find_target(parm[])
{
	new ShacoBox = parm[0]
	new id = parm[1]

	if ( is_valid_ent(ShacoBox) ) {
		
		new classname[32]
		entity_get_string(ShacoBox, EV_SZ_classname, classname, 31)
		if ( equal(classname, "ShacoBox") ) {
			
			gPauseEntity[ShacoBox] = true
			new shortestDistance = get_pcvar_num(gPcvarRadius)	 // def 9999 - 250 - 500
			new nearestPlayer = 0 
			new distance, team[33], rgb[3], players[SH_MAXSLOTS], pnum
			
			// Find all alive enemies and set trail color
			if ( !(id <= id <= SH_MAXSLOTS) || !is_user_alive(id) ) return
			
			get_user_team(id, team, 32) 
			if ( cs_get_user_team(id) == CS_TEAM_CT ) {
				get_players(players, pnum, "ae", "TERRORIST")
				rgb = {50, 50, 175}
				}
			else 	{
				get_players(players, pnum, "ae", "CT")
				rgb = {175, 50, 50}
			}

			// Find the closest enemy
			for (new i = 0; i < pnum; i++) {
				if ( !is_user_alive(players[i]) ) continue

				distance =  get_entity_distance(players[i], ShacoBox)

				if ( distance <= shortestDistance ) {
					shortestDistance = distance
					nearestPlayer = players[i]
				}
			}
 
			// Make the nade seek that enemy if one exists
			if ( nearestPlayer > 0 ) {
				// Trail on grenade
				message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
				write_byte(22)				// TE_BEAMFOLLOW
				write_short(ShacoBox)		// entity:attachment to follow
				write_short(gSpriteTrail)	// sprite index
				write_byte(10)		// life in 0.1's
				write_byte(3)		// line width in 0.1's
				write_byte(rgb[0])	// r
				write_byte(rgb[1])	// g
				write_byte(rgb[2])	// b
				switch(random_num(0,2)) {
					case 0:write_byte(64)	// brightness
					case 1:write_byte(128)
					case 2:write_byte(192)
				} 
				message_end()

				parm[2] = nearestPlayer
				set_task(0.1, "seek_target", ShacoBox+1000, parm, 3, "b")
			}
		}
	}
}

public seek_target(parm[])
{
	new ShacoBox = parm[0]
	new targetn = parm[2]

	if ( !is_valid_ent(ShacoBox) ) {
		remove_task(ShacoBox+1000)
		return 
	}
 
	if ( is_user_alive(targetn) ) {
		entity_set_follow(ShacoBox, targetn) 
	} 
	else 	{
		// Remove the seek loop
		remove_task(ShacoBox+1000)

		// Stop the Trail
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(99)		//TE_KILLBEAM
		write_short(ShacoBox)	// entity
		message_end()

		// Find a new player to seek
		set_task(0.1, "find_target", 0, parm, 3)
	}
}

stock entity_set_follow(entity, target)
{
	if ( !is_valid_ent(entity) || !is_user_alive(target) ) return 0

	new Float:fl_Origin[3], Float:fl_EntOrigin[3]
	entity_get_vector(target, EV_VEC_origin, fl_Origin)
	entity_get_vector(entity, EV_VEC_origin, fl_EntOrigin)

	new Float:fl_InvTime = (gShacoBoxSpeed / vector_distance(fl_Origin, fl_EntOrigin))

	new Float:fl_Distance[3]
	fl_Distance[0] = fl_Origin[0] - fl_EntOrigin[0]
	fl_Distance[1] = fl_Origin[1] - fl_EntOrigin[1]
	fl_Distance[2] = fl_Origin[2] - fl_EntOrigin[2]

	new Float:fl_Velocity[3]
	fl_Velocity[0] = fl_Distance[0] * fl_InvTime
	fl_Velocity[1] = fl_Distance[1] * fl_InvTime
	fl_Velocity[2] = fl_Distance[2] * fl_InvTime

	entity_set_vector(entity, EV_VEC_velocity, fl_Velocity)

	new Float:fl_NewAngle[3]
	vector_to_angle(fl_Velocity, fl_NewAngle)
	entity_set_vector(entity, EV_VEC_angles, fl_NewAngle)

	return 1
}

public fw_entity_think(ent)
{
	if ( ent <= SH_MAXSLOTS || ent > sizeof(gPauseEntity)-1 ) return FMRES_IGNORED

	if ( gPauseEntity[ent] ) {
		new Float:nextThink = entity_get_float(ent, EV_FL_nextthink)
		set_pev(ent, pev_nextthink, nextThink + 0.1)
		return FMRES_SUPERCEDE
	}

	return FMRES_IGNORED
} 

public pfn_touch(ptr, ptd) 
{
	if(!is_valid_ent(ptd) || !is_valid_ent(ptr)) return PLUGIN_CONTINUE		
	if(!is_user_connected(ptd) || !is_user_alive(ptd)) return PLUGIN_CONTINUE	
		
	new classname[32]
	entity_get_string(ptr, EV_SZ_classname, classname, 31)
	if ( equal(classname, "ShacoBox") ) {
		static id;
		id = entity_get_edict(ptr, EV_ENT_owner);
		if ( gHasShaco[id] && get_user_team(id) != get_user_team(ptd) ) {
			sh_set_stun(ptd, get_pcvar_float(gPcvarStun), 1.0);
			ShacoBox_teleport(id);
			remove_entity(ptr);
		}	
	} 
	
	return PLUGIN_CONTINUE 
}
//------------------------------------------------------------------------------------------------
//				Disconected and Round New					//
//------------------------------------------------------------------------------------------------ 
public client_disconnected(id)
	if ( gHasShaco[id] ) remove_shaco(id)

public sh_round_end() {
	for (new id=1; id <= SH_MAXSLOTS; id++) 
		if( gHasShaco[id] ) remove_shaco(id)
}

public sh_round_start()
{
	// Reset any paused entity ids just in case
	for(new i = SH_MAXSLOTS+1; i < sizeof(gPauseEntity)-1; i++) {
		gPauseEntity[i] = false
	}
}
//----------------------------------------------------------------------------------------------
// 			Teleport - Effects n Unstuck
//----------------------------------------------------------------------------------------------
public ShacoBox_teleport(id)
{
	emit_sound(id, CHAN_STATIC, gSound_Shaco, 0.6, ATTN_NORM, 0, PITCH_NORM)
	// sh_set_godmode(id, 1.0)
	set_user_rendering(id, kRenderFxGlowShell, 10, 10, 10, kRenderTransAlpha, 20)
	
	// Thanks to Connor for duck and angles part
	if ( is_user_alive(id) && gFVecOrigin[id][0] ) {
		set_pev(id, pev_flags, pev(id, pev_flags) | FL_DUCKING)
		engfunc(EngFunc_SetSize, id, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX)
		engfunc(EngFunc_SetOrigin, id, gFVecOrigin[id])
		set_pev(id, pev_view_ofs, VEC_DUCK_VIEW)

		set_pev(id, pev_angles, gFVecAngles[id])
		set_pev(id, pev_v_angle, VEC_NULL)
		set_pev(id, pev_fixangle, 1)
	}

	// Teleport Effects
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_TELEPORT)						// 11
	engfunc(EngFunc_WriteCoord, gFVecOrigin[id][0])		// start position
	engfunc(EngFunc_WriteCoord, gFVecOrigin[id][1])
	engfunc(EngFunc_WriteCoord, gFVecOrigin[id][2])
	message_end()
	
	set_task(1.0, "unsetrendering", id)
	
	// If player is stuck, try to unstuck him
	new hulltype = (pev(id, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN
	if ( !sh_hull_vacant(id, gFVecOrigin[id], hulltype) ) {
		unstuck(id, hulltype)
	}  
}

public unsetrendering(id) set_user_rendering(id)
//----------------------------------------------------------------------------------------------
//Thank you from AMXX NS unstuck plugin
unstuck(id, hulltype)
{
	new Float:new_origin[3], distance, i
	distance = 32

	while ( distance < 1000 ) {	// 1000 is just incase, should never get anywhere near that
		for ( i = 0; i < 128; i++ ) {
			new_origin[0] = random_float(gFVecOrigin[id][0] - distance, gFVecOrigin[id][0] + distance)
			new_origin[1] = random_float(gFVecOrigin[id][1] - distance, gFVecOrigin[id][1] + distance)
			new_origin[2] = random_float(gFVecOrigin[id][2] - distance, gFVecOrigin[id][2] + distance)

			if ( fm_trace_hull(new_origin, hulltype, id) == 0 ) {
				engfunc(EngFunc_SetOrigin, id, new_origin)
				return
			}
		}
		distance += 32
	}
}

//Stock from fakemeta_util.inc
stock fm_trace_hull(const Float:origin[3], hull, ignoredent = 0, ignoremonsters = 0) {
	new result = 0;
	engfunc(EngFunc_TraceHull, origin, origin, ignoremonsters, hull, ignoredent > 0 ? ignoredent : 0, 0);

	if (get_tr2(0, TR_StartSolid))
		result += 1;
	if (get_tr2(0, TR_AllSolid))
		result += 2;
	if (!get_tr2(0, TR_InOpen))
		result += 4;

	return result;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1030\\ f0\\ fs16 \n\\ par }
*/
