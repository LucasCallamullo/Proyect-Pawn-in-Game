// ZEUS!

/* CVARS - copy and paste to shconfig.cfg

// Slayer
slayer_level 0
slayer_chance 0.1		//Slay chance
slayer_workinside 0		//Allow zeus to work inside buidings and so on
slayer_cooldown 5			// Time to cooldown
slayer_damage 200			// damage to do it
*/

//---------- User Changeable Defines --------//

// Comment out to use aztec thunder sound, removing the download of a custom thunder sound
// Note: If you change anything here from default setting you must recompile the plugin
#define USE_AZTEC_THUNDER_SOUND

//------- Do not edit below this point ------//
// 0 = DMG TO KILL, i mean kill with one shot, 1 = DAMAGE FOR CVAR
#define DAMAGE_MODE 1

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new const gHeroName[] = "Slayer"
new bool:gHasZeus[SH_MAXSLOTS+1]


new gBurnDecal, gSpriteLightning, gSpriteSmoke

#if defined USE_AZTEC_THUNDER_SOUND
new const gSoundThunder[] = "ambience/thunder_clap.wav"
#else
new const gSoundThunder[] = "shmod/zeus_lightningbolt.wav"
#endif

new gPcvarChance, gPcvarWorkInside, gPcvarCooldown, gPcvarMaxDmg

new Float:gPcvarRealCD[SH_MAXSLOTS+1]
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Zeus", "1.0", "Fr33m@n")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 		= register_cvar("slayer_level", "0")
	gPcvarChance 		= register_cvar("slayer_chance", "10")
	gPcvarWorkInside 	= register_cvar("slayer_workinside", "0")
	gPcvarCooldown	 	= register_cvar("slayer_cooldown", "20")
	gPcvarMaxDmg		= register_cvar("slayer_damage", "200")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Divine Lightning Bolt", "Zeus give you a chance to slay your victim with his Lightning Bolt")

	// Set to correct burn decals if mod is CZ or CS
	gBurnDecal = engfunc(EngFunc_DecalIndex, "{scorch3")
}

public plugin_precache()
{
	gSpriteLightning = precache_model("sprites/lgtning.spr")
	gSpriteSmoke = precache_model("sprites/steam1.spr")
	precache_sound(gSoundThunder)
}
//----------------------------------------------------------------------------------------------
//				INIT
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	gHasZeus[id] = mode ? true : false

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//------------------------------------------------------------------------------------------------
//					Spawn n Death 						//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasZeus[id] ) {
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	}
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if ( gHasZeus[id] )
		gPcvarRealCD[id] = sh_get_cooldown(id)
}
//----------------------------------------------------------------------------------------------
//				DAMAGE EVENT
//----------------------------------------------------------------------------------------------
public client_damage(attacker, victim, damage, wpnindex)
{
	if ( !sh_is_active() ) return
	if ( !is_user_connected(victim) || !is_user_alive(attacker) || gPlayerInCooldown[attacker] ) return
	
	new randnum = random_num(1, 100)
	new slayerchance = get_pcvar_num(gPcvarChance)
 
	if ( gHasZeus[attacker] && wpnindex != (CSW_KNIFE | CSW_HEGRENADE) && slayerchance >= randnum ) {
		// Get the origin of the victim's feet
		new Float:fl_Origin[3]
		pev(victim, pev_origin, fl_Origin)
		fl_Origin[2] -= (pev(victim, pev_flags) & FL_DUCKING) ? 18.0 : 36.0

		if ( !get_pcvar_num(gPcvarWorkInside) ) {
			new Float:fl_TraceEnd[3], Float:fl_EndPos[3]
			fl_TraceEnd[0] = fl_Origin[0] + 1500.0
			fl_TraceEnd[1] = fl_Origin[1] + 1500.0
			fl_TraceEnd[2] = fl_Origin[2] + 8000.0

			new ptr = create_tr2()
			engfunc(EngFunc_TraceLine, fl_Origin, fl_TraceEnd, IGNORE_MONSTERS, victim, ptr)
			get_tr2(ptr, TR_vecEndPos, fl_EndPos)
			free_tr2(ptr)

			// Check if the victim is under the sky or not
			if ( engfunc(EngFunc_PointContents, fl_EndPos) != CONTENTS_SKY ) return
		}

		thunder_effects(fl_Origin)
		// lightningbolt(args[])

		
		#if DAMAGE_MODE == 1
			new maxdamage = get_pcvar_num(gPcvarMaxDmg)
			sh_extra_damage(victim, attacker, maxdamage, "Lightning Bolt")
		#else
			sh_extra_damage(victim, attacker, damage, "Lightning Bolt", 0, SH_DMG_KILL)
		#endif

		// set cooldown
		new Float:seconds = get_pcvar_float(gPcvarCooldown)
		if ( seconds > 0.0 ) {
			sh_set_cooldown(attacker, seconds) 
			gPcvarRealCD[attacker] = seconds 
		}

		// Make the corpse invisible
		sh_set_rendering(victim, 255, 255, 0, 200, kRenderFxGlowShell, kRenderTransAlpha)
		set_task(4.0, "set_normal_glow", victim)
	}
}

public set_normal_glow(victim) 
	sh_set_rendering(victim)
//----------------------------------------------------------------------------------------------
//				EFFECTS THUNDER EVENT
//----------------------------------------------------------------------------------------------
thunder_effects(Float:fl_Origin[3])
{
	new Float:fX = fl_Origin[0], Float:fY = fl_Origin[1], Float:fZ = fl_Origin[2]

	// Thunder sound
	emit_sound(0, CHAN_ITEM, gSoundThunder, VOL_NORM, ATTN_NORM, 0, PITCH_NORM)

	// Beam effect between two points
	engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, fl_Origin, 0)
	write_byte(TE_BEAMPOINTS)		// 0
	engfunc(EngFunc_WriteCoord, fX + 150.0)	// start position
	engfunc(EngFunc_WriteCoord, fY + 150.0)
	engfunc(EngFunc_WriteCoord, fZ + 800.0)
	engfunc(EngFunc_WriteCoord, fX)	// end position
	engfunc(EngFunc_WriteCoord, fY)
	engfunc(EngFunc_WriteCoord, fZ)
	write_short(gSpriteLightning)	// sprite index
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500)  	// width
	write_byte(2)   		// noise
	write_byte(230)   	// r, g, b
	write_byte(230)   	// r, g, b
	write_byte(50)   	// r, g, b
	write_byte(1000)   	// brightness
	write_byte(2)      	// speed
	message_end()

	// Sparks
	message_begin(MSG_PVS, SVC_TEMPENTITY)
	write_byte(TE_SPARKS)			// 9
	engfunc(EngFunc_WriteCoord, fX)	// position
	engfunc(EngFunc_WriteCoord, fY)
	engfunc(EngFunc_WriteCoord, fZ + 10.0)
	message_end()

	// Smoke
	engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, fl_Origin, 0)
	write_byte(TE_SMOKE)			// 5
	engfunc(EngFunc_WriteCoord, fX)	// position
	engfunc(EngFunc_WriteCoord, fY)
	engfunc(EngFunc_WriteCoord, fZ + 10.0)
	write_short(gSpriteSmoke)		// sprite index
	write_byte(10)					// scale in 0.1's
	write_byte(10)					// framerate
	message_end()
	
	// Blood
	engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, fl_Origin, 0)
	write_byte(TE_LAVASPLASH)		// 10
	engfunc(EngFunc_WriteCoord, fX)	// position
	engfunc(EngFunc_WriteCoord, fY)
	engfunc(EngFunc_WriteCoord, fZ + 12.0)
	message_end()
	
	// Burn decal
	engfunc(EngFunc_MessageBegin, MSG_BROADCAST, SVC_TEMPENTITY, fl_Origin, 0)
	write_byte(TE_GUNSHOTDECAL)		// 109
	engfunc(EngFunc_WriteCoord, fX)	// position
	engfunc(EngFunc_WriteCoord, fY)
	engfunc(EngFunc_WriteCoord, fZ)
	write_short(0)
	write_byte(gBurnDecal + random(3))	// decal
	message_end()
	
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
