/*
Version 0.1 posted
Version 0.2 Fixed by Om3g[A] ( on the original code was some compline errors )
*/ 
 // 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#define TE_BEAMPOINTS 0
#define TE_EXPLOSION 3
#define TE_EXPLOSION2 12
 
#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[] = "Zeus"
new bool:gHasStormPower[SH_MAXSLOTS+1]

new gStormTimer[SH_MAXSLOTS+1]
new lightning, Fire, gMsgSync
new pcvarAdmin, gPcvarCooldown, gPcvarTime, gPcvarRadius, gPcvarMaxDmg

// This is for cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1] 
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Zeus","0.2","[FTW]-S.W.A.T/Om3g[A]")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel	= register_cvar("storm_level", "10" )
	gPcvarCooldown	= register_cvar("storm_cooldown", "20" )
	gPcvarTime	= register_cvar("storm_time", "15")
	gPcvarRadius	= register_cvar("storm_radius", "200")
	gPcvarMaxDmg	= register_cvar("storm_maxdamage", "150")
	pcvarAdmin	= register_cvar("storm_adminflag", "p")
	
	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel);
	sh_set_hero_info(gHeroID, "El Dios del Trueno. (Only Admin!).", "Tormenta de truenos que caen por el mapa, tene cuidado!");
	sh_set_hero_bind(gHeroID); 

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	//LOOP
	set_task(1.0, "storm_zeus_loop", _, "", _, "b")

	// CreateHudSyncObj
	gMsgSync = CreateHudSyncObj()
}
 
public plugin_precache()
{
	lightning 	= precache_model("sprites/lgtning.spr")
	Fire 		= precache_model("sprites/zerogxplode.spr")
}
 //------------------------------------------------------------------------------------------------
//				Hero INIT and KEY						//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode) {
		case SH_HERO_ADD: {
			gHasStormPower[id] = true
			gPlayerInCooldown[id] = false
			gStormTimer[id] = -1
			Storm_admincheck(id)
		}
		case SH_HERO_DROP: {
			gHasStormPower[id] = false;
			gStormTimer[id] = -1
		}
	}
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasStormPower[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] ) {
			playSoundDenySelect(id)
			return;
		}
		
		gStormTimer[id] = get_pcvar_num(gPcvarTime)+1
	}
}
#if SEND_COOLDOWN
public sendZeusCooldown(id)
{
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id])
}
#endif
//------------------------------------------------------------------------------------------------
//				Efectos Zues Power						//
//------------------------------------------------------------------------------------------------
public storm_zeus_loop()
{
	static players[SH_MAXSLOTS], playerCount, id, i
	get_players(players, playerCount, "ah")

	for ( i = 0; i < playerCount; i++ ) {
		id = players[i]
		
		if ( gStormTimer[id] < 0 ) continue
		if ( !gHasStormPower[id] || !is_user_alive(id) ) continue
		
		if ( gStormTimer[id] > 0 ) {
			
			set_task(random_num(1,2)*1.0,"lightningbolt", id)
			set_hudmessage(255,0,0,-1.0, 0.3, 0, 0.0, 1.0, 0.0, 0.0, 4)
			ShowSyncHudMsg(id, gMsgSync, "%d segundos antes de que termine la Tormenta.", gStormTimer[id] )
		}
		else if ( gStormTimer[id] == 0 ) {
			
			gStormTimer[id] = -1
			// set cooldown
			new Float:seconds = get_pcvar_float(gPcvarCooldown)
			if ( seconds > 0.0 ) {
				sh_set_cooldown(id, seconds)
				gPcvarRealCD[id] = seconds 
			}
		}
			
		gStormTimer[id]--
	}
}

public DamageRadius(id, Float: origin[3]) 
{
	static damage, FFOn, Float: radius
	damage 	= get_pcvar_num(gPcvarMaxDmg)
	radius 	= get_pcvar_float(gPcvarRadius)
	FFOn 	= get_cvar_num("mp_friendlyfire")
	
	new Float:distanceBetween, Float: dRatio
	
	static players[SH_MAXSLOTS], playerCount, vic, i
	get_players(players, playerCount, "ah")

	for ( i = 0; i < playerCount; i++ ) {
		vic = players[i]
		
		if ( !is_user_alive(vic) || vic == id ) continue
		if ( get_user_team(id) != get_user_team(vic) || FFOn ) {
			
			new Float:origin1[3]

			pev(vic, pev_origin, origin1)
			distanceBetween = vector_distance(origin, origin1 )

			if( distanceBetween < radius ) {
				dRatio = distanceBetween / radius
				new adjdmg = damage - floatround(damage * dRatio)
				sh_extra_damage(vic, id, adjdmg, "Storm Lightning")
			} 	// distance
		} 	// alive target...
	}	// loop
}
//------------------------------------------------------------------------------------------------
//					Spawn n Death 						//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasStormPower[id] ) {
		gStormTimer[id] = -1
		Storm_admincheck(id)
		
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	} 
} 

public sh_client_death(id) 
{
	// Para obtener la cantidad real de cooldown que tiene el poder
	if ( gHasStormPower[id] ) { 
		gPcvarRealCD[id] = sh_get_cooldown(id)
		gStormTimer[id] = -1
	}
}
//------------------------------------------------------------------------------------------------
//				THUNDER EFFECTS							//
//------------------------------------------------------------------------------------------------
// public lightningbolt(args[])
public lightningbolt(id)
{
 	// new id = args[0]
	new inum
	
	for (new i=1; i <= SH_MAXSLOTS; i++) {
		if ( is_user_alive(i) ) inum++
	}

	new Float:origin[3]
	new porigin1[3],porigin2[3],forigin[3]
	new victim = random_num(1, inum)
	new victim2 = random_num(1, inum)
	get_user_origin(victim,porigin1)
	get_user_origin(victim2,porigin2)
	forigin[0]=(porigin1[0]+porigin2[0])/2
	forigin[1]=(porigin1[1]+porigin2[1])/2
	forigin[2]=(porigin1[2]+porigin2[2])/2
	origin[0]=float(forigin[0]+random_num(1,500))
	origin[1]=float(forigin[1]+random_num(1,500))
	origin[2]=float(forigin[2])

//	forigin[0] = floatround(origin[0])
//	forigin[1] = floatround(origin[1])
//	forigin[2] = floatround(origin[2])

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning) 	// model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500) 	// width
	write_byte(2)   		// noise
	write_byte(230)   	// r, g, b
	write_byte(230)  	// r, g, b
	write_byte(50)   	// r, g, b
	write_byte(1000)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0])-10)
	write_coord(floatround(origin[1])-10)
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning)  // model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500)  	// width
	write_byte(2)   		// noise
	write_byte(230)   	// r, g, b
	write_byte(230)   	// r, g, b
	write_byte(50)   	// r, g, b
	write_byte(1000)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0])+10)
	write_coord(floatround(origin[1])+10)
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning) 	// model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500)  	// width
	write_byte(2)   		// noise
	write_byte(255)   	// r, g, b
	write_byte(240)   	// r, g, b
	write_byte(201)   	// r, g, b
	write_byte(900)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(50)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0])+50)
	write_coord(floatround(origin[1])+50)
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(100)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0])-50)
	write_coord(floatround(origin[1])-50)
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(150)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST,SVC_TEMPENTITY)
	write_byte(TE_EXPLOSION2)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2]))
	write_byte(188) 	// start color
	write_byte(10) 		// num colors
	message_end()
	
	
	DamageRadius(id, origin)
}
//------------------------------------------------------------------------------------------------
//				Disconected / ADmin Check					//
//------------------------------------------------------------------------------------------------
public client_disconnected(id)
{
	if ( id <= 0 || id > SH_MAXSLOTS ) return
	// Yeah don't want any left over residuals
	remove_task(id)
	gHasStormPower[id] = false
	gStormTimer[id] = -1
}

public Storm_admincheck(id) 
{
   	if ( !gHasStormPower[id] ) return
	
   	new accessLevel[10]
	get_pcvar_string(pcvarAdmin, accessLevel, 9)
	
	if (equali(accessLevel, "0")) return
   	
	// Para controlar si tiene admin
	if ( !(get_user_flags(id)&read_flags(accessLevel)) ) {
		sh_chat_message(id, gHeroID, "[Only Admin] Conseguite Admin Rata.")
      		client_cmd(id, "say drop %s", gHeroName)
		gHasStormPower[id] = false
   	}
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
