/*
Version 0.1 posted
Version 0.2 Fixed by Om3g[A] ( on the original code was some compline errors )
*/ 
 // 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#define TE_BEAMPOINTS 0
#define TE_EXPLOSION 3
#define TE_EXPLOSION2 12
 
#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Zeus"
new bool:gHasStormPower[SH_MAXSLOTS+1]
new bool:gStormSelected[SH_MAXSLOTS+1]
new gStormTimer[SH_MAXSLOTS+1]
new lightning, Fire, gPcvarCooldown, gPcvarTime, gPcvarRadius, gPcvarMaxDmg, gMsgSync
#if SEND_COOLDOWN
	new Float:ZeusUsedTime[SH_MAXSLOTS+1]
#endif
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Zeus","0.2","[FTW]-S.W.A.T/Om3g[A]")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	if ( isDebugOn() ) server_print("Llamando a los truenos por Zeus.")
	new pcvarLevel	= register_cvar("storm_level", "10" )
	gPcvarCooldown	= register_cvar("storm_cooldown", "20" )
	gPcvarTime	= register_cvar("storm_time", "15")
	gPcvarRadius	= register_cvar("storm_radius", "200")
	gPcvarMaxDmg	= register_cvar("storm_maxdamage", "150")
	register_cvar("storm_adminflag", "p")
	
	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel);
	sh_set_hero_info(gHeroID, "El Dios del Trueno. (Only Admin!).", "Tormenta de truenos que caen por el mapa, tene cuidado!");
	sh_set_hero_bind(gHeroID); 

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	//LOOP
	// set_task(1.0, "Storm_loop", 0, "", 0, "b" )
	// register_srvcmd("Storm_loop", "Storm_loop")

	// CreateHudSyncObj
	gMsgSync = CreateHudSyncObj()
}
 
public plugin_precache()
{
	lightning = precache_model("sprites/lgtning.spr")
	Fire = precache_model("sprites/zerogxplode.spr")
}
 //------------------------------------------------------------------------------------------------
//				Hero INIT and KEY						//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode) {
		case SH_HERO_ADD: {
			gHasStormPower[id] = true
			gPlayerInCooldown[id] = false
			gStormSelected[id] = gHasStormPower[id]
			Storm_admincheck(id)
			remove_task(id+1337)
		}
		case SH_HERO_DROP: {
			gHasStormPower[id] = false;
		}
	}
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !gHasStormPower[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] ) {
			playSoundDenySelect(id)
			return;
		}
		
		gStormTimer[id] = get_pcvar_num(gPcvarTime)+1

		new args[1]
		args[0] = id 
		set_task(1.0, "Storm_loop", id+1337, "", 0, "b" )
		set_task(1.0, "randomtime", id+1337, args,1, "a", gStormTimer[id] )
		
		#if SEND_COOLDOWN
			ZeusUsedTime[id] = get_gametime()
		#endif
	}
	
}
#if SEND_COOLDOWN
public sendZeusCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(gPcvarCooldown) + get_pcvar_num(gPcvarTime) + 1 - get_gametime() + ZeusUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
//------------------------------------------------------------------------------------------------
//				Efectos Zues Power						//
//------------------------------------------------------------------------------------------------
public randomtime(args[])
{
 	new id = args[0]
	set_task(random_num(1,4)*1.0,"lightningbolt",id+1337,args,1)
	set_task(random_num(1,4)*1.0,"lightningbolt",id+1337,args,1)
	//set_task(random_num(1,4)*1.0,"randomtime",id+1337)
}

public Storm_loop()
{
 	if (!hasRoundStarted()) return

	for ( new id=1; id<=SH_MAXSLOTS; id++ ) {
		if ( gHasStormPower[id] && is_user_alive(id)  ) {
			if ( gStormTimer[id]>0 ) {
				gStormTimer[id]--
				set_hudmessage(255,0,0,-1.0, 0.3, 0, 0.0, 1.0, 0.0, 0.0, 4)
				ShowSyncHudMsg(id, gMsgSync, "%d segundos antes de que termine la Tormenta.", gStormTimer[id] )
				}
			else 	{
				if ( gStormTimer[id] == 0 ) {
					gStormTimer[id] = -1
					remove_task(id+1337)
					new Float:seconds = get_pcvar_float(gPcvarCooldown)
					if ( seconds > 0.0 ) sh_set_cooldown(id, seconds)
				}
			}
		}
	}
}

public DamageRadius(id,Float: origin[3]) 
{
	new Float: distanceBetween
	new damage = get_pcvar_num(gPcvarMaxDmg)
	new Float: radius = get_pcvar_float(gPcvarRadius)
	new FFOn = get_cvar_num("mp_friendlyfire")
	for(new vic = 1; vic <= SH_MAXSLOTS; vic++) {
		if( is_user_alive(vic) && ( get_user_team(id) != get_user_team(vic) || FFOn != 0 || vic!=id ) ) {
			new Float:origin1[3]
			//get_user_origin(vic,origin1)
			pev(vic, pev_origin, origin1)
			distanceBetween = vector_distance(origin, origin1 )

			//client_print(id, print_chat, "debug - origin %d, %d, %d", origin[0],origin[1],origin[2])
			//client_print(id, print_chat, "debug - distanceBetween %d", distanceBetween)
			if( distanceBetween < radius ) {
				new Float: dRatio = distanceBetween / radius
				new adjdmg = damage - floatround(damage * dRatio)
				shExtraDamage(vic, id, adjdmg, "Storm Lightning")
			} 	// distance
		} 	// alive target...
	}	// loop
}
 //------------------------------------------------------------------------------------------------
//				Spawn y Efectos de RAyos					//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
 	gPlayerUltimateUsed[id]=false
 	gStormTimer[id] = -1
	remove_task(id+1337)
}

public lightningbolt(args[])
{
 	new id = args[0]
	new inum

	for (new i=1; i <= SH_MAXSLOTS; i++) {
		if (is_user_alive(i) ) inum++
	}

	new Float:origin[3]
	new porigin1[3],porigin2[3],forigin[3]
	new victim = random_num(1,inum)
	new victim2 = random_num(1,inum)
	get_user_origin(victim,porigin1)
	get_user_origin(victim2,porigin2)
	forigin[0]=(porigin1[0]+porigin2[0])/2
	forigin[1]=(porigin1[1]+porigin2[1])/2
	forigin[2]=(porigin1[2]+porigin2[2])/2
	origin[0]=float(forigin[0]+random_num(1,500))
	origin[1]=float(forigin[1]+random_num(1,500))
	origin[2]=float(forigin[2])

//	forigin[0] = floatround(origin[0])
//	forigin[1] = floatround(origin[1])
//	forigin[2] = floatround(origin[2])

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning) 	// model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500) 	// width
	write_byte(2)   		// noise
	write_byte(230)   	// r, g, b
	write_byte(230)  	// r, g, b
	write_byte(50)   	// r, g, b
	write_byte(1000)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0])-10)
	write_coord(floatround(origin[1])-10)
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning)  // model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500)  	// width
	write_byte(2)   		// noise
	write_byte(230)   	// r, g, b
	write_byte(230)   	// r, g, b
	write_byte(50)   	// r, g, b
	write_byte(1000)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_BEAMPOINTS)
	write_coord(floatround(origin[0])+10)
	write_coord(floatround(origin[1])+10)
	write_coord(floatround(origin[2])+1000000)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2])-20000)
	write_short(lightning) 	// model
	write_byte(1) 		// start frame
	write_byte(20) 		// framerate
	write_byte(6) 		// life
	write_byte(500)  	// width
	write_byte(2)   		// noise
	write_byte(255)   	// r, g, b
	write_byte(240)   	// r, g, b
	write_byte(201)   	// r, g, b
	write_byte(900)   	// brightness
	write_byte(2)      	// speed
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(50)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0])+50)
	write_coord(floatround(origin[1])+50)
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(100)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST, SVC_TEMPENTITY )
	write_byte(TE_EXPLOSION)
	write_coord(floatround(origin[0])-50)
	write_coord(floatround(origin[1])-50)
	write_coord(floatround(origin[2]))
	write_short(Fire)
	write_byte(100)
	write_byte(150)
	write_byte(0)
	message_end()

	message_begin( MSG_BROADCAST,SVC_TEMPENTITY)
	write_byte(TE_EXPLOSION2)
	write_coord(floatround(origin[0]))
	write_coord(floatround(origin[1]))
	write_coord(floatround(origin[2]))
	write_byte(188) 	// start color
	write_byte(10) 		// num colors
	message_end()
	DamageRadius(id,origin)
	return PLUGIN_HANDLED
}
//------------------------------------------------------------------------------------------------
//				Disconected / ADmin Check					//
//------------------------------------------------------------------------------------------------
public client_disconnected(id)
{
	if ( id <= 0 || id > SH_MAXSLOTS ) return
	// Yeah don't want any left over residuals
	remove_task(id+1337)
	gHasStormPower[id] = false
	gStormTimer[id] = -1
}

public Storm_admincheck(id) 
{
   	new accessLevel[10] 
	get_cvar_string("storm_adminflag", accessLevel, 9)
   	
	if ( gStormSelected[id] &&  !(get_user_flags(id)&read_flags(accessLevel)) ) {
		sh_chat_message(id, gHeroID, "[Only Admin] No estás autorizado a usar este Héroe.")
      		gHasStormPower[id] = false
      		client_cmd(id, "say drop %s", gHeroName)
   	}
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
