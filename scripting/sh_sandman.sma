// SANDMAN! - from Marvel Comics, possesses the ability to convert all or part of his body into a sand-like substance by mental command.

/* CVARS - copy and paste to shconfig.cfg

//Sandman
sandman_level 9
sandman_cooldown 20		//Seconds before you can use quicksand again (Default 20)
sandman_duration 5		//How long quicksand lasts
sandman_affected 30		//Seconds before the target can be affected by quicksand again

*/
/*
* v1.3.1 - heliumdream - 7/3/2016 
*          - added some z-height to the return origin to 'unstick' affected targets.
*          - fixed a logic error.
*/
/*
* v1.3 - heliumdream - 6/28/2016 
*        - added sandman_affected cvar
*        - added WasHitBySandman array global variable to flag affected users
		 - added remove_affect function to reverse the flag
		 - added a check on new_spawn to reset the flag. 
*/
/*
* v1.2 - heliumdream - 6/27/2016
*        - added sandman_duration cvar
*        - created 'unsink' and 'unsink_effects' functions, basically reversing the existing sink and sink_effects. 
*/
/*
* v1.1 - vittu - 4/2/06
*      - Re-coded and cleaned up.
*      - Renamed to Sandman since it fits better.
*      - Added extra checks preventing from being buried too far
*          and to make sure user is buryable able.
*      - Changed cooldown to only set if you bury someone.
*      - Removed ability to bury team mates.
*
*   Hero Originally named Quicksand created by Freecode.
*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new HeroName[]="Sandman"
new bool:HasSandman[SH_MAXSLOTS+1]

new bool:WasHitBySandman[SH_MAXSLOTS+1]

new MSGSetFOV, gMsgSync
new gPcvarCooldown, gPcvarDuration, gPcvarAffected

// This is for cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1]  

// this for unstuck
new Float:gFVecOrigin[SH_MAXSLOTS+1][3]

//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Sandman", "1.1", "Freecode/vittu")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 	= register_cvar("sandman_level", "9")
	gPcvarCooldown	= register_cvar("sandman_cooldown", "20")
	gPcvarDuration	= register_cvar("sandman_duration", "5")
	gPcvarAffected	= register_cvar("sandman_affected", "30")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(HeroName, pcvarLevel);
	sh_set_hero_info(gHeroID, "Trampa de Arena.", "Usa Arena en 1 enemigo en tu Punto de Mira para atraparlo en una Trampa de Arena.");
	sh_set_hero_bind(gHeroID);

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// Sets field of view
	MSGSetFOV = get_user_msgid("SetFOV")
	
	gMsgSync = CreateHudSyncObj()
}
//------------------------------------------------------------------------------------------------
//				Hero INIT and KEY						//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) 
{ 
	if ( heroID != gHeroID ) return
    
	switch(mode) {
		case SH_HERO_ADD: {
			HasSandman[id] = true
			gPlayerInCooldown[id] = false
		}
		case SH_HERO_DROP: {
			HasSandman[id] = false;
		}
	}
}

public sh_hero_key(id, heroID, key) 
{ 
	if ( heroID != gHeroID || !sh_is_inround() ) return;
	if ( !is_user_alive(id) || !HasSandman[id] ) return;
    
	if ( key == SH_KEYDOWN ) {
		
		if ( gPlayerUltimateUsed[id] ) {
			playSoundDenySelect(id)
			return;
		}
		
		quicksand(id)
	}
}
#if SEND_COOLDOWN
public sendSandmanCooldown(id)
{
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id])
} 
#endif
//------------------------------------------------------------------------------------------------
//					Spawn n Death 						//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( HasSandman[id] ) {
	
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	}
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if ( HasSandman[id] ) {
		gPcvarRealCD[id] = sh_get_cooldown(id)
	}
}

public sh_round_end()
{
	for ( new id = 1; id <= SH_MAXSLOTS; id++ ) {

		if ( task_exists(id) ) remove_task(id)
	
		if (WasHitBySandman[id]) {
			// Reset Zoom
			message_begin(MSG_ONE, MSGSetFOV, {0,0,0}, id)
			write_byte(90)	//Normal, not Zooming
			message_end()
		}
		
		WasHitBySandman[id] = false	
	}
}

public quicksand(id)
{
	new targetid, body
	get_user_aiming(id, targetid, body)

	if ( !is_user_alive(targetid) || get_user_team(id) == get_user_team(targetid) )
		targetid = 0

	switch(targetid) {
		case 0: {
			sh_chat_message(id, gHeroID, "No se encontro un objetivo.")
			sh_sound_deny(id)
			return
		}
		default: {
			// Get origin at this point so if they move it will keep them in the same spot
			new origin[3]
			get_user_origin(targetid, origin)

			new Float:testOrigin[3]
			IVecFVec(origin, testOrigin)
			
			if ( PointContents(testOrigin) == -2 ) {
				sh_chat_message(id, gHeroID, "El objetivo esta en la Arena Movediza.")
				sh_sound_deny(id)
				return
			}

			if ( WasHitBySandman[targetid] ) {
				sh_chat_message(id, gHeroID, "El objetivo fue afectado recientemente por la Arena Movediza.")
				sh_sound_deny(id)
				return
			}

			if ( !(entity_get_int(targetid, EV_INT_flags)&FL_ONGROUND) ) {
				sh_chat_message(id, gHeroID, "El Objetivo no estÃ¡ en la tierra.")
				playSoundDenySelect(id)
				return
			}
			
			// Set cooldown
			new Float:seconds = get_pcvar_float(gPcvarCooldown)
			if ( seconds > 0.0 ) {
				sh_set_cooldown(id, seconds)
				gPcvarRealCD[id] = seconds
			}

			sinking_effects(id, targetid)
			

			// efectos para que no sea afectado todo el tiempo entre rondas
			WasHitBySandman[targetid] = true
			new Float:affect_length = get_pcvar_float(gPcvarAffected)
			new ra_params[1]
			ra_params[0] = targetid
			set_task(affect_length, "remove_affect", id, ra_params, 1)

			new params[6]
			params[0] = origin[0]
			params[1] = origin[1]
			params[2] = origin[2]
			params[3] = targetid
			params[4] = id
			params[5] = 40		// this is the amount effect sink into the earth

			sink(params)
		}
	}
}

public remove_affect(param[])
{
	new id = param[0]	
	WasHitBySandman[id] = false
}
//------------------------------------------------------------------------------------------------
//				SINK EFFECTS / ENTIERRO EFFECTS					//
//------------------------------------------------------------------------------------------------
public sink(params[])
{
	new targetid = params[3]
	new id = params[4]

	if ( !is_user_alive(targetid) || !HasSandman[id] ) return
	
	if ( params[5] > 0 ) {	// is_user_alive(targetid) // is_user_connected(id)  
		// Causes this function to repeat until it equals 0
		--params[5]

		new origin[3]
		origin[0] = params[0]
		origin[1] = params[1]
		origin[2] = --params[2]

		set_user_origin(targetid, origin)
		set_task(0.1, "sink", id, params, 6)
		}
	else 	{
		new Float:duration = get_pcvar_float(gPcvarDuration)
		set_task(duration, "unsink", id, params, 6)
	}
	
	if ( !is_user_alive(id) )
		set_task(0.1, "unsink", id, params, 6)
}

public sinking_effects(id, targetid)
{
	if ( !is_user_alive(targetid) || !HasSandman[id] ) return

	new targname[32], idname[32]
	get_user_name(targetid, targname, 31)
	get_user_name(id, idname, 31)

	set_hudmessage(46, 139, 87, -1.0, 0.24, 0, 1.0, 4.0, 0.0, 0.0, 3)
	ShowSyncHudMsg(id, gMsgSync, "%s Fue atrapado en tu Arena Movediza.", targname)
	ShowSyncHudMsg(targetid, gMsgSync, "%s's Fuiste atrapado en su Arena Movediza.", idname)
	
	sh_set_rendering(targetid, 255, 222, 173, 20, kRenderFxGlowShell)

	// Set targets field of view
	message_begin(MSG_ONE, MSGSetFOV, {0,0,0}, targetid)
	write_byte(135)
	message_end()
}
//------------------------------------------------------------------------------------------------
//			UNSINK EFFECTS / DESENTIERRO EFFECTS					//
//------------------------------------------------------------------------------------------------
public unsink(parameters[])
{
	new targetid = parameters[3]
	new id = parameters[4]	

	new origin[3]
	origin[0] = parameters[0]
	origin[1] = parameters[1]
	origin[2] = parameters[2] + 40	

	set_user_origin(targetid, origin)
	
	// Save users origin on death
	pev(targetid, pev_origin, gFVecOrigin[targetid])
 
	// If player is stuck, try to unstuck him
	new hulltype = (pev(targetid, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN
	if ( !sh_hull_vacant(targetid, gFVecOrigin[targetid], hulltype) ) {
		unstuck(targetid, hulltype) 
	} 
	
	unsink_effects(id, targetid)
}

public unsink_effects(id, targetid)
{
	new targname[32], idname[32]
	get_user_name(targetid, targname, 31)
	get_user_name(id, idname, 31)

	set_hudmessage(46, 139, 87, -1.0, 0.24, 0, 1.0, 4.0, 0.0, 0.0, 3)
	
	ShowSyncHudMsg(id, gMsgSync, "%s Ha sido liberado de tu Arena Movediza.", targname)
	ShowSyncHudMsg(targetid, gMsgSync, "%s's Fuiste liberado de su Arena Movediza.", idname)
	
	sh_set_rendering(targetid)

	// Reset Zoom
	message_begin(MSG_ONE, MSGSetFOV, {0,0,0}, targetid)
	write_byte(90)	//Normal, not Zooming
	message_end()
}

//----------------------------------------------------------------------------------------------
//Thank you from AMXX NS unstuck plugin
unstuck(id, hulltype)
{
	new Float:new_origin[3], distance, i
	distance = 32

	while ( distance < 1000 ) {	// 1000 is just incase, should never get anywhere near that
		for ( i = 0; i < 128; i++ ) {
			new_origin[0] = random_float(gFVecOrigin[id][0] - distance, gFVecOrigin[id][0] + distance)
			new_origin[1] = random_float(gFVecOrigin[id][1] - distance, gFVecOrigin[id][1] + distance)
			new_origin[2] = random_float(gFVecOrigin[id][2] - distance, gFVecOrigin[id][2] + distance)

			if ( fm_trace_hull(new_origin, hulltype, id) == 0 ) {
				engfunc(EngFunc_SetOrigin, id, new_origin)
				return
			}
		}
		distance += 32
	}
}

//Stock from fakemeta_util.inc
stock fm_trace_hull(const Float:origin[3], hull, ignoredent = 0, ignoremonsters = 0) {
	new result = 0;
	engfunc(EngFunc_TraceHull, origin, origin, ignoremonsters, hull, ignoredent > 0 ? ignoredent : 0, 0);

	if (get_tr2(0, TR_StartSolid))
		result += 1;
	if (get_tr2(0, TR_AllSolid))
		result += 2;
	if (!get_tr2(0, TR_InOpen))
		result += 4;

	return result;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
