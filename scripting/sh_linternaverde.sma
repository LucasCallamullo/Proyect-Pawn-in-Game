/*
//Green Lantern
// Make sure the cooldown period is longer than the shield existance time.

greenlantern_level 6
greenlantern_cooldown 30 //Cooldown between each use
greenlantern_existance 5 //Shield existance
*/
/*
*   Green Lantern's Shield
*		Thanx to vittu's cooldown kd as base and AssKicR's spawn infront code.
*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1
//------- Do not edit below this point ------//

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[] = "Linterna Verde"
new bool:gHasGreenPower[SH_MAXSLOTS+1]

// entity for each player.
new gLanternShield[SH_MAXSLOTS+1]

new gPcvarCooldown, gPcvarExistance

new const gEnt_Lantern[] = "models/shmod/wall.mdl" 

// This is for cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1]  
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Linterna Verde", "1.0", "Yang")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 	= register_cvar("greenlantern_level", "3")
	gPcvarCooldown	= register_cvar("greenlantern_cooldown", "6")
	gPcvarExistance	= register_cvar("greenlantern_existance","6.0")

	// FIRE THE EVENTS TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Muros de ProtecciÃ³n.", "Crea una Pantalla Verde para cubrirte de las balas. - Pone en say /bind para aprender a bindear." )
	sh_set_hero_bind(gHeroID)

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
}

public plugin_precache()
{
	precache_model(gEnt_Lantern)
	// precache_sound("debris/bustglass1.wav")
}
//------------------------------------------------------------------------------------------------
//				Hero INIT and KEY						//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	switch(mode) {
		case SH_HERO_ADD: {
			gHasGreenPower[id] = true
		}
		case SH_HERO_DROP: {
			gHasGreenPower[id] = false
		}
	}

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public sh_hero_key(id, heroID, key)
{
	if ( gHeroID != heroID || !sh_is_inround() ) return
	if ( !is_user_alive(id) || !gHasGreenPower[id] ) return

	if ( key == SH_KEYDOWN ) {		
			if ( gPlayerInCooldown[id] ) {
				sh_sound_deny(id)
				return
			}
			
			// check if exists another wall before create new
			remove_shield(id)
			
			create_shield(id)
			
			// Set Cooldown
			new Float:seconds = get_pcvar_float(gPcvarCooldown)
			if ( seconds > 0.0 ) {
				sh_set_cooldown(id, seconds)
				gPcvarRealCD[id] = seconds
			}
	}
}	
#if SEND_COOLDOWN
public sendLanternCooldown(id)
{
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id]) 
}
#endif
//------------------------------------------------------------------------------------------------
//					Spawn n Death 						//
//------------------------------------------------------------------------------------------------
public sh_client_spawn(id)
{
	if ( gHasGreenPower[id] ) {
		remove_shield(id)
	
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	}
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if ( gHasGreenPower[id] ) gPcvarRealCD[id] = sh_get_cooldown(id)
}
//------------------------------------------------------------------------------------------------
//				Create Shield							//
//------------------------------------------------------------------------------------------------
public create_shield(id) 
{
	// create de entity
	gLanternShield[id] = create_entity("info_target")
	entity_set_string(gLanternShield[id], EV_SZ_classname, "gl_shield")
	entity_set_model(gLanternShield[id], gEnt_Lantern)
	
	// Set size and absmin+absmax values
	new Float:mins[] = {-90.0, -10.0, -20.0};
	new Float:maxs[] = {90.0,  10.0,  75.0};
	entity_set_vector(gLanternShield[id], EV_VEC_mins, mins)
	entity_set_vector(gLanternShield[id], EV_VEC_maxs, maxs)
	entity_set_vector(gLanternShield[id], EV_VEC_absmin, mins)
	entity_set_vector(gLanternShield[id], EV_VEC_absmax, maxs)
	
	// Set Glow Verde Green
	new Float:glowColor[3] = {0.0, 255.0, 0.0}
	entity_set_int(gLanternShield[id], EV_INT_renderfx, kRenderFxGlowShell)
	entity_set_vector(gLanternShield[id], EV_VEC_rendercolor, glowColor)
	entity_set_int(gLanternShield[id], EV_INT_rendermode, kRenderTransAlpha)
	entity_set_float(gLanternShield[id], EV_FL_renderamt, 40.0 )
	
	/*/ Set Hp
	entity_set_float(gLanternShield[id], EV_FL_health, 1000.0)
	entity_set_float(gLanternShield[id], EV_FL_takedamage, DAMAGE_YES) */
	
	// Set angle
	new Float:angles[] = {0.0, 90.0, 0.0}
	entity_set_vector(gLanternShield[id], EV_VEC_angles, angles)
	
	// Get user origin
	new Float:someOrigin[3]
	entity_get_vector(id, EV_VEC_origin, someOrigin)
	
	// You can offset the origin here.
	new offset = 200
	new Float:adjustPos[3]
	velocity_by_aim(id, offset, adjustPos)
	
	// This prevents the wall from spawning in the current position of the user and make it spawn farther away from the user.
	someOrigin[0] += adjustPos[0]
	someOrigin[1] += adjustPos[1]
	someOrigin[2] += adjustPos[2]
	entity_set_origin(gLanternShield[id], someOrigin)
	
	// Set other values
	entity_set_edict(gLanternShield[id], EV_ENT_owner, id)
	entity_set_int(gLanternShield[id], EV_INT_solid, SOLID_BBOX)
	entity_set_int(gLanternShield[id], EV_INT_movetype, 5)
	
	new Float:vRetVector[3]
	entity_get_vector(id, EV_VEC_v_angle, vRetVector)
	vRetVector[0] = float(0)
	entity_set_vector(gLanternShield[id], EV_VEC_angles, vRetVector)

	if( ((vRetVector[1]>=45.0) && (vRetVector[1]<=135.0)) || ((vRetVector[1]>=-135.0) && (vRetVector[1]<=-45.0)) ) {
		entity_set_size(gLanternShield[id], Float:{-90.0,-5.0,-156.0}, Float:{90.0,5.0,156.0} )
		}
	else 	{
		entity_set_size(gLanternShield[id], Float:{-5.0,-90.0,-156.0}, Float:{5.0,90.0,156.0} )
	}
	
	set_task(get_pcvar_float(gPcvarExistance), "remove_shield", id )
	
	new parm[1]
	parm[0] = id
	glow_effect(parm)
	set_task(0.1, "glow_effect", 0, parm, 2, "a", 40)
}

//----------------------------------------------------------------------------------------------
// 			REMOVE ENTITY
//----------------------------------------------------------------------------------------------
public remove_shield(id)
{
	if ( !is_valid_ent(gLanternShield[id]) ) return		// this is for engine
	// if ( !pev_valid(gLanternShield[id]) ) return		// this is for fakemeta maybe the same function

	if ( gLanternShield[id] ) {
		set_pev(gLanternShield[id], pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, gLanternShield[id]);
		gLanternShield[id] = 0;
	}
}

public glow_effect(parm[])
{
	new float:vec1[3]
	new id = parm[0]
	get_user_origin(id, vec1, 0)
	message_begin(MSG_ONE, SVC_TEMPENTITY, vec1, id)
	write_byte(27) 		//TE_DLIGHT  dynamic light, effect world, minor entity effect
	write_coord(vec1[0]) 	//initial position
	write_coord(vec1[1])
	write_coord(vec1[2])
	write_byte(20) 		//radius in 10's
	write_byte(5) 		//color red
	write_byte(220) 	//color green
	write_byte(5) 		//color blue
	write_byte(1) 		//life in 10's
	write_byte(5) 		//decay rate in 10's
	message_end()
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
