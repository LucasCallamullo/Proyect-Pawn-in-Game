/*
//Green Lantern
// Make sure the cooldown period is longer than the shield existance time.

greenlantern_level 6
greenlantern_cooldown 30 //Cooldown between each use
greenlantern_existance 5 //Shield existance
*/
/*
*   Green Lantern's Shield
*		Thanx to vittu's cooldown kd as base and AssKicR's spawn infront code.
*/
// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1
//------- Do not edit below this point ------//

#include <superheromod>

// GLOBAL VARIABLES
new gHeroID
new gHeroName[]="Linterna Verde"
new bool:gHasGreenPower[SH_MAXSLOTS+1]
new gLanternShield[SH_MAXSLOTS+1]

// new bool:gBlockKeyup[SH_MAXSLOTS+1]
// new gLastWeapon[SH_MAXSLOTS+1]

new gPcvarCooldown, gPcvarExistance
#if SEND_COOLDOWN
	new Float:LanternUsedTime[SH_MAXSLOTS+1]
#endif
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Linterna Verde", "1.0", "Yang")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel 	= register_cvar("greenlantern_level", "3")
	gPcvarCooldown	= register_cvar("greenlantern_cooldown", "6")
	gPcvarExistance	= register_cvar("greenlantern_existance","6.0")

	// FIRE THE EVENTS TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Muros de ProtecciÃ³n.", "Crea una Pantalla Verde para cubrirte de las balas. - Pone en say /bind para aprender a bindear." )
	sh_set_hero_bind(gHeroID)

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// register_concmd("shield", "create_shield")
}

public plugin_precache()
{
	precache_model("models/shmod/wall.mdl")
	precache_sound("debris/bustglass1.wav")
}
//------------------------------------------------------------------------------------------------
//				Hero INIT and KEY						//
//------------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode)
{
	if ( gHeroID != heroID ) return

	switch(mode) {
		case SH_HERO_ADD: {
			gHasGreenPower[id] = true
		}
		case SH_HERO_DROP: {
			gHasGreenPower[id] = false
		}
	}

	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}

public sh_hero_key(id, heroID, key)
{
	if ( gHeroID != heroID || !sh_is_inround() ) return
	if ( !is_user_alive(id) || !gHasGreenPower[id] ) return

	//switch(key) {
	//	case SH_KEYDOWN: {
	if ( key == SH_KEYDOWN ) {		
			if ( gPlayerInCooldown[id] ) {
				sh_sound_deny(id)
				// gBlockKeyup[id] = true
				return
			}
			/*
			gBlockKeyup[id] = false
			// Remember this weapon...
			new clip, ammo, weaponID = get_user_weapon(id, clip, ammo)
			gLastWeapon[id] = weaponID */
			
			create_shield(id)
			
			// Sey Cooldown
			new Float:seconds = get_pcvar_float(gPcvarCooldown)
			if ( seconds > 0.0 ) {
				sh_set_cooldown(id, seconds)
				#if SEND_COOLDOWN
					LanternUsedTime[id] = get_gametime()
				#endif
			}
	}
		/* case SH_KEYUP: {
			// Switch back to previous weapon...
			if ( gBlockKeyup[id] ) return
			// Use keyup since if called too fast CurWeapon functions may be bypassed
			if (gLastWeapon[id] != CSW_KNIFE) shSwitchWeaponID(id, gLastWeapon[id])
		} */
	// }
}	
#if SEND_COOLDOWN
public sendLanternCooldown(id)
{
	new cooldown
	if (gPlayerInCooldown[id])
		cooldown = floatround( get_pcvar_num(gPcvarCooldown) - 0.6 - get_gametime() + LanternUsedTime[id] + 0.4 )
	else
		cooldown = -1
	return cooldown
}
#endif
public sh_client_spawn(id)
{
	if ( gHasGreenPower[id] && is_user_alive(id) ) {
		gPlayerUltimateUsed[id] = false
		remove_shield(id)
		/* new remove_shield = find_ent_by_class(-1, "gl_shield")
		while(remove_shield) {
			remove_entity(remove_shield)
			remove_shield = find_ent_by_class(remove_shield, "gl_shield")
		} 
		
		new gl_shield = find_ent_by_class(-1, "gl_shield")
		while(gl_shield) {
			remove_entity(gl_shield)
			gl_shield = find_ent_by_class(gl_shield, "gl_shield") 
		}*/
	}
}
//------------------------------------------------------------------------------------------------
//				Create Shield							//
//------------------------------------------------------------------------------------------------
public create_shield(id) 
{
	// gLanternShield[id] = create_entity("func_breakable")
	// if ( !is_valid_ent(gLanternShield[id]) ) return

	gLanternShield[id] = create_entity("info_target")
	entity_set_string(gLanternShield[id], EV_SZ_classname, "gl_shield")
	entity_set_model(gLanternShield[id], "models/shmod/wall.mdl") // I found it somewhere in the forums
	// Set size and absmin+absmax values
	new Float:mins[3]
	new Float:maxs[3]
	mins[0] = -90.0
	mins[1] = -10.0
	mins[2] = -20.0
	maxs[0] = 90.0
	maxs[1] = 10.0
	maxs[2] = 75.0
	entity_set_vector(gLanternShield[id], EV_VEC_mins, mins)
	entity_set_vector(gLanternShield[id], EV_VEC_maxs, maxs)
	entity_set_vector(gLanternShield[id], EV_VEC_absmin, mins)
	entity_set_vector(gLanternShield[id], EV_VEC_absmax, maxs)
	// Set Glow Verde Green
	new Float:glowColor[3] = {0.0, 255.0, 0.0}
	entity_set_int(gLanternShield[id], EV_INT_renderfx, kRenderFxGlowShell)
	entity_set_vector(gLanternShield[id], EV_VEC_rendercolor, glowColor)
	entity_set_int(gLanternShield[id], EV_INT_rendermode, kRenderTransAlpha)
	entity_set_float(gLanternShield[id], EV_FL_renderamt, 40.0 )
	/*/ Set Hp
	entity_set_float(gLanternShield[id], EV_FL_health, 1000.0)
	entity_set_float(gLanternShield[id], EV_FL_takedamage, DAMAGE_YES) */
	// Set angle
	mins[0] = 0.0
	mins[1] = 90.0
	mins[2] = 0.0
	entity_set_vector(gLanternShield[id], EV_VEC_angles, mins)
	// Get user origin
	new Float:someOrigin[3]
	entity_get_vector(id, EV_VEC_origin, someOrigin)
	// You can offset the origin here.
	new offset = 200
	new Float:adjustPos[3]
	velocity_by_aim(id, offset, adjustPos)
	// This prevents the wall from spawning in the current position of the user and make it spawn farther away from the user.
	someOrigin[0] += adjustPos[0]
	someOrigin[1] += adjustPos[1]
	someOrigin[2] += adjustPos[2]
	entity_set_origin(gLanternShield[id], someOrigin)
	// Set other values
	new LanterOwner = id
	entity_set_edict(gLanternShield[id], EV_ENT_owner, LanterOwner)
	entity_set_int(gLanternShield[id], EV_INT_solid, SOLID_BBOX)
	entity_set_int(gLanternShield[id], EV_INT_movetype, 5)
	
	new Float:vRetVector[3]
	entity_get_vector(id, EV_VEC_v_angle, vRetVector)
	vRetVector[0]=float(0)
	entity_set_vector(gLanternShield[id], EV_VEC_angles, vRetVector)

	if( ((vRetVector[1]>=45.0) && (vRetVector[1]<=135.0)) || ((vRetVector[1]>=-135.0) && (vRetVector[1]<=-45.0)) ) {
		entity_set_size(gLanternShield[id], Float:{-90.0,-5.0,-156.0}, Float:{90.0,5.0,156.0} )
		}
	else 	{
		entity_set_size(gLanternShield[id], Float:{-5.0,-90.0,-156.0}, Float:{5.0,90.0,156.0} )
	}
	
	set_task(get_pcvar_float(gPcvarExistance), "remove_shield", id )
	new parm[1]
	parm[0] = id
	glow_effect(parm)
	set_task(0.1, "glow_effect", 0, parm, 2, "a", 40)
}

public remove_shield(id)
{
	new entLantern = gLanternShield[id]
	if(entLantern != -1 && pev_valid(entLantern)) {
		new szClassname[32];
		pev(entLantern, pev_classname, szClassname, 31);
		if(equal(szClassname, "gl_shield")) {
			set_pev(entLantern, pev_flags, FL_KILLME)
			dllfunc(DLLFunc_Think, entLantern)
			gLanternShield[id] = -1;
		}
	}
	
	/* if ( pev_valid(gLanternShield[id]) ) 
		pev(entity, pev_flags, FL_KILLME);
		dllfunc(DLLFunc_Think, susanoo) */
		//remove_entity(gLanternShield[id])
}

public glow_effect(parm[])
{
	new float:vec1[3]
	new id = parm[0]
	get_user_origin(id, vec1, 0)
	message_begin(MSG_ONE, SVC_TEMPENTITY, vec1, id)
	write_byte(27) 		//TE_DLIGHT  dynamic light, effect world, minor entity effect
	write_coord(vec1[0]) 	//initial position
	write_coord(vec1[1])
	write_coord(vec1[2])
	write_byte(20) 		//radius in 10's
	write_byte(5) 		//color red
	write_byte(220) 	//color green
	write_byte(5) 		//color blue
	write_byte(1) 		//life in 10's
	write_byte(5) 		//decay rate in 10's
	message_end()
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang11274\\ f0\\ fs16 \n\\ par }
*/
