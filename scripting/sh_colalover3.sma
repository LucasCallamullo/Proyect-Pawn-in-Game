/* Plugin generated by AMXX-Studio */
/*
//Cola Lover
coca_level 9		//Nivel del cola Lover
coca_health 900		//Cuanta Hp te da
coca_armor 900		//cuanta armor da
coca_speed 550		//velocidad que te da
coca_grenadetimer 6.0	// cada cuanto tiempo te da otra fb
fn_color team

*/

// 1 = send another plugins information about cooldown, 0 = don't send
#define SEND_COOLDOWN 1

#include <superheromod>

#define AMMOX_FLASHBANG 11

#define message_begin_fl(%1,%2,%3,%4) engfunc(EngFunc_MessageBegin, %1, %2, %3, %4)
#define write_coord_fl(%1) engfunc(EngFunc_WriteCoord, %1)

#define m_pPlayer			41
#define m_pActiveItem		373
#define m_flFlashedUntil	514
#define m_flFlashHoldTime	517
#define OFFSET_WEAPON_CSWID	43
#define Ham_Player_ResetMaxSpeed Ham_Item_PreFrame

#define MAX_WEAPONS		32
#define AMMO_FLASHBANG		11
#define AMMO_HEGRENADE		12
#define AMMO_SMOKEGRENADE	13
#define DMG_GRENADE		(1<<24) // thanks arkshine
#define FFADE_IN			0x0000 // just here so we don't pass 0 into the function
#define BREAK_GLASS		0x01
#define STATUS_HIDE		0
#define STATUS_SHOW		1
#define STATUS_FLASH		2

#define GLOW_AMOUNT		1.0
#define FROST_RADIUS		240.0

#define NT_FLASHBANG		(1<<0) // 1; CSW:25
#define NT_HEGRENADE		(1<<1) // 2; CSW:4
#define NT_SMOKEGRENADE		(1<<2) // 4; CSW:9

new const GRENADE_NAMES[][] = {
	// "weapon_hegrenade",
	"weapon_flashbang"
	// "weapon_smokegrenade"
};

#define ICON_HASNADE		1
#define ICON_ISCHILLED		2

#define TASK_REMOVE_CHILL	100
#define TASK_REMOVE_FREEZE	200

new const MODEL_FROZEN[]	= "models/shmod/colafrozen.mdl";
new const MODEL_GLASSGIBS[]	= "models/glassgibs.mdl";

new const SOUND_EXPLODE[]	= "x/x_shoot1.wav";
new const SOUND_FROZEN[]	= "debris/glass1.wav";
new const SOUND_UNFROZEN[]	= "debris/glass3.wav";
new const SOUND_CHILLED[]	= "player/pl_duct2.wav";
new const SOUND_PICKUP[]	= "items/gunpickup2.wav";

new const SPRITE_TRAIL[]	= "sprites/laserbeam.spr";
new const SPRITE_SMOKE[]	= "sprites/steam1.spr";
new const SPRITE_EXPLO[]	= "sprites/shockwave.spr";

new pcv_enabled, pcv_override, pcv_nadetypes, pcv_teams, pcv_color, pcv_icon,
		pcv_by_radius, pcv_hitself, pcv_los, pcv_maxdamage, pcv_mindamage, pcv_chill_maxchance, pcv_chill_minchance,
		pcv_chill_duration, pcv_chill_variance, pcv_chill_speed, pcv_freeze_maxchance, pcv_freeze_minchance,
		pcv_freeze_duration, pcv_freeze_variance;

new maxPlayers, gmsgScreenFade, gmsgStatusIcon, 
		glassGibs, trailSpr, smokeSpr, exploSpr, mp_friendlyfire, czero, bot_quota, czBotHams, fmFwdPPT,
		fnFwdPlayerChilled, fnFwdPlayerFrozen, bool:roundRestarting;

new isChilled[33], isFrozen[33], frostKilled[33], novaDisplay[33], Float:glowColor[33][3], Float:oldGravity[33], oldRenderFx[33],
		Float:oldRenderColor[33][3], oldRenderMode[33], Float:oldRenderAmt[33], hasFrostNade[33], nadesBought[33];

new gHeroID
new gHeroName[] = "Cola Lover" 
new bool:gHasColaLoverPower[SH_MAXSLOTS+1]

new bool:BlockGiveNade[SH_MAXSLOTS+1]
new CvarGrenadeReset

new const gCoca_grenade_v[] = "models/shmod/cokegrenade_v.mdl"
new const gCoca_grenade_p[] = "models/shmod/cokegrenade_p.mdl"  
new const gCoca_grenade_w[] = "models/shmod/cokegrenade_w.mdl"  

// This is for cooldowns
new Float:gPcvarRealCD[SH_MAXSLOTS+1]  
//------------------------------------------------------------------------------------------------
//				Plugin Init and Precache					//
//------------------------------------------------------------------------------------------------
public plugin_init() 
{
	register_plugin("SUPERHERO Cocacola", "1.0", "LucasCab")
	
	//cvars 
	new pcvarLevel 		= register_cvar("coca_level", "9")
	new pcvarHealth 	= register_cvar("coca_health", "900")
	CvarGrenadeReset 	= register_cvar("coca_grenadetimer", "6.0") //segundos para reponder la nade
	
	pcv_enabled 	= register_cvar("fn_enabled","1");
	pcv_override 	= register_cvar("fn_override","1");    // para que reemplaze a la fb
	pcv_nadetypes 	= register_cvar("fn_nadetypes","1"); // NT_SMOKEGRENADE = 4 // 1 = Flashbang
	pcv_teams 	= register_cvar("fn_teams","3");	//lo usan ambos equipos = 3
	pcv_icon 	= register_cvar("fn_icon","2");	// 1 = muestra que tenes una coca; 2 muestra cuando congelan; 0 no hace nada
	pcv_color 	= register_cvar("fn_color","team"); // el default medio turquesa es ( 0 206 209)

	pcv_by_radius 	= register_cvar("fn_by_radius","0.0");	// dejar en 0 porque funca mejor asi que decirte
	pcv_hitself 	= register_cvar("fn_hitself","1");	// si se puede congelar solo
	pcv_los 	= register_cvar("fn_los","1");
	pcv_maxdamage 	= register_cvar("fn_maxdamage","2.0");	// daño al centro de la explosion
	pcv_mindamage 	= register_cvar("fn_mindamage","1.0");	// daño al borde de la explosion
	pcv_chill_maxchance 	= register_cvar("fn_chill_maxchance","100.0");
	pcv_chill_minchance 	= register_cvar("fn_chill_minchance","100.0");
	pcv_chill_duration 	= register_cvar("fn_chill_duration","7.0");	// cuanto tiempo se chill
	pcv_chill_variance 	= register_cvar("fn_chill_variance","1.0");  // cuanto puede variar el tiempo de chill +-1
	pcv_chill_speed 	= register_cvar("fn_chill_speed","50.0");	// a que velocidad se mueve si esta solo chill
	pcv_freeze_maxchance 	= register_cvar("fn_freeze_maxchance","110.0");	//chance de congelarse al centro
	pcv_freeze_minchance 	= register_cvar("fn_freeze_minchance","35.0");	//chance de congelarse al borde
	pcv_freeze_duration 	= register_cvar("fn_freeze_duration","3.0");	//cuanto dura la congelacion
	pcv_freeze_variance 	= register_cvar("fn_freeze_variance","1.0");	//variacion de congeliacion
	
	mp_friendlyfire	= get_cvar_pointer("mp_friendlyfire");
	
	//Hero
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Amas la Coca-Cola.", "ObtÃ©n los poderes de la Coca-Cola, MÃ¡s HP/AP y una Flash con gaseosa pegajosa que realentiza/congela cada cierto tiempo.")
	
	//agregados para controlar variables.
	sh_set_hero_hpap(gHeroID, pcvarHealth, pcvarHealth)
	
	//Eventos
	// register_event("CurWeapon", "weapon_change", "be", "1=1")
	register_event("AmmoX", "on_Ammox", "b")
	
	new mod[6];
	get_modname(mod,5);
	if(equal(mod,"czero")) {
		czero = 1;
		bot_quota = get_cvar_pointer("bot_quota");
	}
	
	maxPlayers = get_maxplayers();
	gmsgScreenFade = get_user_msgid("ScreenFade");
	gmsgStatusIcon = get_user_msgid("StatusIcon");

	register_forward(FM_SetModel,"fw_setmodel",1);
	register_message(get_user_msgid("DeathMsg"),"msg_deathmsg");
	
	register_event("TextMsg", "event_round_restart", "a", "2=#Game_Commencing", "2=#Game_will_restart_in");
	register_event("HLTV", "event_new_round", "a", "1=0", "2=0");

	RegisterHam(Ham_Spawn,"player","ham_player_spawn",1);
	RegisterHam(Ham_Killed,"player","ham_player_killed",1);
	RegisterHam(Ham_Player_ResetMaxSpeed,"player","ham_player_resetmaxspeed",1);
	RegisterHam(Ham_Think,"grenade","ham_grenade_think",0);
	RegisterHam(Ham_Use, "player_weaponstrip", "ham_player_weaponstrip_use", 1);
	
	for(new i=0; i<sizeof GRENADE_NAMES; i++) {
		RegisterHam(Ham_Item_Deploy, GRENADE_NAMES[i], "ham_grenade_deploy", 1);
	}
	
	fnFwdPlayerChilled = CreateMultiForward("frostnades_player_chilled", ET_STOP, FP_CELL, FP_CELL);
	fnFwdPlayerFrozen  = CreateMultiForward("frostnades_player_frozen",  ET_STOP, FP_CELL, FP_CELL);
}

public plugin_precache()
{
	precache_model(MODEL_FROZEN);
	glassGibs = precache_model(MODEL_GLASSGIBS);

	precache_sound(SOUND_EXPLODE); // grenade explodes
	precache_sound(SOUND_FROZEN); // player is frozen
	precache_sound(SOUND_UNFROZEN); // frozen wears off
	precache_sound(SOUND_CHILLED); // player is chilled
	precache_sound(SOUND_PICKUP); // player buys frostnade

	trailSpr = precache_model(SPRITE_TRAIL);
	smokeSpr = precache_model(SPRITE_SMOKE);
	exploSpr = precache_model(SPRITE_EXPLO);
	
	precache_model(gCoca_grenade_v)
	precache_model(gCoca_grenade_p)
	precache_model(gCoca_grenade_w)
}
//-----------------------------------------------------------------------------
public sh_hero_init(id, HeroID, mode)
{
	if (gHeroID != HeroID) return
 
	switch(mode) {
		case SH_HERO_ADD: {
			gHasColaLoverPower[id] = true
			gPlayerInCooldown[id] = false
			coca_weapon(id)
			switch_model(id)
		} 
		case SH_HERO_DROP: {
			gHasColaLoverPower[id] = false
		}
	}
}
//--------------------------------------------------------------------------------------------------------------
public plugin_end()
{
	DestroyForward(fnFwdPlayerChilled);
	DestroyForward(fnFwdPlayerFrozen);
}

public client_putinserver(id)
{
	if ( !shModActive() || !gHasColaLoverPower[id] ) return
		
	isChilled[id] = 0;
	isFrozen[id] = 0;
	frostKilled[id] = 0;
	novaDisplay[id] = 0;
	hasFrostNade[id] = 0;
	
	if(czero && !czBotHams && is_user_bot(id) && get_pcvar_num(bot_quota) > 0)
		set_task(0.1,"czbot_hook_ham",id);
}

public client_disconnected(id)
{
	if(isChilled[id]) task_remove_chill(TASK_REMOVE_CHILL+id);
	if(isFrozen[id]) task_remove_freeze(TASK_REMOVE_FREEZE+id);
}

// registering a ham hook for "player" won't register it for CZ bots,
// for some reason. so we have to register it by entity. 
public czbot_hook_ham(id)
{
	if ( !shModActive() || !gHasColaLoverPower[id] ) return

	if(!czBotHams && is_user_connected(id) && is_user_bot(id) && get_pcvar_num(bot_quota) > 0)
	{
		RegisterHamFromEntity(Ham_Spawn,id,"ham_player_spawn",1);
		RegisterHamFromEntity(Ham_Killed,id,"ham_player_killed",1);
		RegisterHamFromEntity(Ham_Player_ResetMaxSpeed,id,"ham_player_resetmaxspeed",1);
		czBotHams = 1;
	}
}

// intercept server log messages to replace grenade kills with frostgrenade kills
public plugin_log()
{
	static arg[512];
	
	if(get_pcvar_num(pcv_enabled) && read_logargc() >= 5)
	{
		read_logargv(1, arg, 7); // "killed"
		
		if(equal(arg, "killed"))
		{
			read_logargv(2, arg, 127); // info of player that was killed
			
			// get ID of player that was killed
			new dummy[1], killedUserId;
			parse_loguser(arg, dummy, 0, killedUserId);
			new killedId = find_player("k", killedUserId);
			
			if(killedId && frostKilled[killedId])
			{	
				// override with frostgrenade message
				read_logdata(arg, 511);
				replace(arg, 511, "with ^"grenade^"", "with ^"frostgrenade^"");				
				log_message("%s", arg);

				return PLUGIN_HANDLED;
			}
		}
	}
	
	return PLUGIN_CONTINUE;
}

// entity is given a model (used to detect for thrown grenades)
public fw_setmodel(ent,model[])
{
	if(!get_pcvar_num(pcv_enabled)) return FMRES_IGNORED;
	
	//if(!pev_valid(ent)) return FMRES_IGNORED

	new owner = pev(ent,pev_owner);
	if(!is_user_connected(owner)) return FMRES_IGNORED;
	if ( !shModActive() || !gHasColaLoverPower[owner]) return FMRES_IGNORED;
	
	// this isn't going to explode
	new Float:dmgtime;
	pev(ent,pev_dmgtime,dmgtime);
	if(dmgtime == 0.0) return FMRES_IGNORED;
	
	new type, csw;
	if(model[7] == 'w' && model[8] == '_')
	{
		switch(model[9])
		{
			case 'h': { type = NT_HEGRENADE; csw = CSW_HEGRENADE; }
			case 'f': { type = NT_FLASHBANG; csw = CSW_FLASHBANG; }
			case 's': { type = NT_SMOKEGRENADE; csw = CSW_SMOKEGRENADE; }
		}
	}
	if(!type) return FMRES_IGNORED;
	
	new team = _:cs_get_user_team(owner);

	// have a frostnade (override off) ;OR; override enabled, on valid team, using valid frostnade type
	if(hasFrostNade[owner] == csw && gHasColaLoverPower[owner] || (get_pcvar_num(pcv_override)
			&& (get_pcvar_num(pcv_teams) & team) && (get_pcvar_num(pcv_nadetypes) & type)))
	{
		// not using override
		if(hasFrostNade[owner] == csw) {
			hasFrostNade[owner] = 0;
			if(get_pcvar_num(pcv_icon) == ICON_HASNADE) {
				show_icon(owner, STATUS_HIDE);
			}
		}

		set_pev(ent,pev_team,team);
		set_pev(ent,pev_bInDuck,1); // flag it as a frostnade

		new rgb[3], Float:rgbF[3];
		get_rgb_colors(team,rgb);
		IVecFVec(rgb, rgbF);
		
		// glowshell
		set_pev(ent,pev_rendermode,kRenderNormal);
		set_pev(ent,pev_renderfx,kRenderFxGlowShell);
		set_pev(ent,pev_rendercolor,rgbF);
		set_pev(ent,pev_renderamt,16.0);

		set_beamfollow(ent,10,10,rgb,100);
	}

	return FMRES_IGNORED;
}

// freeze a player in place whilst he's frozen
public fw_playerprethink(id)
{
	if ( !shModActive() || !gHasColaLoverPower[id] ) return FMRES_IGNORED;
	
	if(isFrozen[id] && gHasColaLoverPower[id]) {
		set_pev(id,pev_velocity,Float:{0.0,0.0,0.0}); // stop motion
		
		new Float:gravity;
		pev(id,pev_gravity,gravity);
		
		// remember any gravity changes
		if(gravity != 0.000000001 && gravity != 999999999.9)
			oldGravity[id] = gravity;

		// if are on the ground and about to jump, set the gravity too high to really do so
		if((pev(id,pev_button) & IN_JUMP) && !(pev(id,pev_oldbuttons) & IN_JUMP) && (pev(id,pev_flags) & FL_ONGROUND))
			set_pev(id,pev_gravity,999999999.9);

		// otherwise, set the gravity so low that they don't fall
		else set_pev(id,pev_gravity,0.000000001);
	}
	
	return FMRES_IGNORED;
}

// override grenade kill message with skull and crossbones
public msg_deathmsg(msg_id,msg_dest,msg_entity)
{
	new victim = get_msg_arg_int(2);
	if(!is_user_connected(victim) || !frostKilled[victim]) return PLUGIN_CONTINUE;

	static weapon[8];
	get_msg_arg_string(4,weapon,7);
	if(equal(weapon,"grenade")) set_msg_arg_string(4,"frostgrenade");

	//frostKilled[victim] = 0;
	return PLUGIN_CONTINUE;
}

// catch HUD reset to re-display icon if necessary
public sh_client_spawn(id)
{
	if(!is_user_alive(id) || !get_pcvar_num(pcv_enabled)) return;

	//set_user_chillfreeze_speed(id);
	sh_reset_max_speed(id)
	
	if(get_pcvar_num(pcv_icon) == ICON_HASNADE ) { 
		new status = player_has_frostnade(id);
		show_icon(id, status);
	}
	
	if ( gHasColaLoverPower[id] ) {
		BlockGiveNade[id] = true
		set_task(0.1,"coca_weapon",id)
		
		// Para controlar si esta en ronda y tener el cooldown real.
		if ( sh_is_inround() ) {
			if ( gPcvarRealCD[id] > 0.0 ) sh_set_cooldown(id, gPcvarRealCD[id])
			// False = Nace sin cooldowsn, True = Nace con cooldown.
			else gPlayerInCooldown[id] = false
		}
		// if is a new round set cooldown in zero
		else gPlayerInCooldown[id] = false
	} 
}

public sh_client_death(id) {
	// Para obtener la cantidad real de cooldown que tiene el poder
	if (gHasColaLoverPower[id]) gPcvarRealCD[id] = sh_get_cooldown(id)
}
 
#if SEND_COOLDOWN
public sendColaLoverCooldown(id)
{
	gPcvarRealCD[id] = sh_get_cooldown(id)
	return floatround(gPcvarRealCD[id])
}
#endif
//-----------------------------------------------------------------------------------------------
public coca_weapon(id) if ( is_user_alive(id) ) sh_give_weapon(id, CSW_FLASHBANG)

// some kind of grenade is deployed
public ham_grenade_deploy(ent)
{	
	if(pev_valid(ent)) {
		grenade_deployed(get_pdata_cbase(ent, m_pPlayer, 4),
			get_pdata_int(ent, OFFSET_WEAPON_CSWID, 4));
	}
	
	new id = get_pdata_cbase(ent, 41, 4)	// 41 y 4 son constantes van siempre
	if ( !is_user_alive(id) || !gHasColaLoverPower[id] ) return HAM_IGNORED;
	set_pev(id, pev_viewmodel2, gCoca_grenade_v)
	
	return HAM_IGNORED; 
}

// handle when player id deploys a grenade with weapon id wid
grenade_deployed(id, wid)
{
	if ( !gHasColaLoverPower[id] ) return
	
	// if we should worry about managing my icon now
	if(get_pcvar_num(pcv_enabled) && is_user_alive(id) && get_pcvar_num(pcv_icon) == ICON_HASNADE) {
		// if I just switched to a frost grenade
		if( wid == hasFrostNade[id]
			|| (get_pcvar_num(pcv_override) && (get_pcvar_num(pcv_teams) & _:cs_get_user_team(id)) && is_wid_in_nadetypes(wid)) )
		{
			show_icon(id, STATUS_FLASH);
		}
	}
}
//----------------------------------------------------------------------------------------------
switch_model(id)
{
	if ( !gHasColaLoverPower[id] || !is_user_alive(id) ) return
	
	if (get_user_weapon(id) == CSW_FLASHBANG) {
		set_pev(id, pev_viewmodel2, gCoca_grenade_v)
		set_pev(id, pev_weaponmodel2, gCoca_grenade_p)
	}
}
//Fin? 
//----------------------------------------------------------------------------------------------
public on_Ammox(id)
{
	if ( !shModActive() || !is_user_alive(id) || !gHasColaLoverPower[id] ) return

	new iAmmoType = read_data(1)
	new iAmmoCount = read_data(2)

	if ( iAmmoType == AMMOX_FLASHBANG ) {
		if ( iAmmoCount == 0 && !BlockGiveNade[id] ) {
			
			if ( !gPlayerInCooldown[id] ) {
				new iGrenade = -1
				while ( (iGrenade = find_ent_by_class(iGrenade, "grenade")) > 0 ) {
					new model[32]
					entity_get_string(iGrenade, EV_SZ_model, model, 31)
					if ( id == entity_get_edict(iGrenade, EV_ENT_owner) && equal(model, "models/w_flashbang.mdl") ) {
						entity_set_model(iGrenade, gCoca_grenade_w)
					}
				}
			}
			
			// set cooldown
			new Float:seconds = get_pcvar_float(CvarGrenadeReset)
			if ( seconds > 0.0 ) {
				sh_set_cooldown(id, seconds)
				gPcvarRealCD[id] = seconds
				
				//This will be called on spawn as well as when nade is thrown, block this on spawn.
				//Nade was thrown set task to give another.
				set_task(get_pcvar_float(CvarGrenadeReset), "coca_weapon", id)
			}
		}	
		
		else if ( iAmmoCount > 0 ) {
			BlockGiveNade[id] = false	// Either has a smoke nade or was given one on spawn, ok to allow sound and task now
			remove_task(id)			// Got a new smoke nade remove the timer
		}
	}
}
//----------------------------------------------------------------------------------------------
//			ESTO ES DEL FROSTNADE
//----------------------------------------------------------------------------------------------
// round is restarting (TAG: sv_restartround)
public event_round_restart()
{
	// just remember for event_new_round
	roundRestarting = true;
}

// start of a new round
public event_new_round()
{
	if(roundRestarting) {
		roundRestarting = false;
		// clear frost grenades from all players (for override mode)
		for(new i=1;i<=maxPlayers;i++) {
			hasFrostNade[i] = 0;
		}
	}
}
// rezzed
public ham_player_spawn(id)
{
	nadesBought[id] = 0;
	
	if(is_user_alive(id)) {
		if(isChilled[id]) task_remove_chill(TASK_REMOVE_CHILL+id);
		if(isFrozen[id]) task_remove_freeze(TASK_REMOVE_FREEZE+id);
	}
	
	return HAM_IGNORED;
}
// killed to death
public ham_player_killed(id)
{
	//if ( !shModActive() || !gHasColaLoverPower[id] ) return HAM_IGNORED;
	hasFrostNade[id] = 0;
	
	if(get_pcvar_num(pcv_enabled) && get_pcvar_num(pcv_icon) == ICON_HASNADE) {
		show_icon(id, STATUS_HIDE);
	}

	if(isChilled[id]) task_remove_chill(TASK_REMOVE_CHILL+id);
	if(isFrozen[id]) task_remove_freeze(TASK_REMOVE_FREEZE+id);
	
	return HAM_IGNORED;
}
// movement speed is changed
public ham_player_resetmaxspeed(id)
{
	if(get_pcvar_num(pcv_enabled)) {
		set_user_chillfreeze_speed(id);
	}

	return HAM_IGNORED;
}
// grenade is ticking away
public ham_grenade_think(ent)
{
	// not a frostnade
	if(!pev_valid(ent) || !pev(ent,pev_bInDuck)) 
		return HAM_IGNORED;
	
	new Float:dmgtime;
	pev(ent,pev_dmgtime,dmgtime);
	if(dmgtime > get_gametime()) 
		return HAM_IGNORED;
	
	// and boom goes the dynamite
	frostnade_explode(ent);
	
	return HAM_SUPERCEDE;			//este es el original
}

// a player_weaponstrip is used
public ham_player_weaponstrip_use(ent, idcaller, idactivator, use_type, Float:value)
{
	if ( !shModActive() || !gHasColaLoverPower[idcaller] ) return HAM_IGNORED;
	
	if(idcaller >= 1 && idcaller <= maxPlayers) //&& gHasColaLoverPower[idcaller]
	{
		// clear frostnade when using override
		hasFrostNade[idcaller] = 0;

		if(is_user_alive(idcaller) && get_pcvar_num(pcv_enabled) && get_pcvar_num(pcv_icon) == ICON_HASNADE)
		{
			new status = player_has_frostnade(idcaller);
			show_icon(idcaller, status);
		}
	}

	return HAM_IGNORED;
}

// a frost grenade explodes
public frostnade_explode(ent)
{	
	new nadeTeam = pev(ent,pev_team), owner = pev(ent,pev_owner), Float:nadeOrigin[3];
	pev(ent,pev_origin,nadeOrigin);
	
	// make the smoke
	message_begin_fl(MSG_PVS,SVC_TEMPENTITY,nadeOrigin,0);
	write_byte(TE_SMOKE);
	write_coord_fl(nadeOrigin[0]); // x
	write_coord_fl(nadeOrigin[1]); // y
	write_coord_fl(nadeOrigin[2]); // z
	write_short(smokeSpr); // sprite
	write_byte(random_num(30,40)); // scale
	write_byte(5); // framerate
	message_end();
	
	// explosion
	create_blast(nadeTeam,nadeOrigin);
	emit_sound(ent,CHAN_ITEM,SOUND_EXPLODE,VOL_NORM,ATTN_NORM,0,PITCH_HIGH);

	// cache our cvars
	new ff = get_pcvar_num(mp_friendlyfire), Float:by_radius = get_pcvar_float(pcv_by_radius),
			hitself = get_pcvar_num(pcv_hitself), los = get_pcvar_num(pcv_los), Float:maxdamage = get_pcvar_float(pcv_maxdamage),
			Float:mindamage = get_pcvar_float(pcv_mindamage), Float:chill_maxchance = get_pcvar_float(pcv_chill_maxchance),
			Float:chill_minchance = get_pcvar_float(pcv_chill_minchance), Float:freeze_maxchance, Float:freeze_minchance;

	if(!by_radius)
	{
		freeze_maxchance = get_pcvar_float(pcv_freeze_maxchance);
		freeze_minchance = get_pcvar_float(pcv_freeze_minchance);
	}

	new ta, Float:targetOrigin[3], Float:distance, tr = create_tr2(), Float:fraction, Float:damage, gotFrozen = 0;
	for(new target=1;target<=maxPlayers;target++)
	{
		// dead, invincible, or self attack that is not allowed
		if(!is_user_alive(target) || pev(target,pev_takedamage) == DAMAGE_NO
		|| (pev(target,pev_flags) & FL_GODMODE) ||(target == owner && !hitself))
			continue;
		
		// this is a team attack with ff disabled, excluding self attack
		ta = (_:cs_get_user_team(target) == nadeTeam);
		if(ta && !ff && target != owner) continue;
		
		pev(target,pev_origin,targetOrigin);
		distance = vector_distance(nadeOrigin,targetOrigin);
		
		// too far
		if(distance > FROST_RADIUS) continue;

		// check line of sight
		if(los)
		{
			nadeOrigin[2] += 2.0;
			engfunc(EngFunc_TraceLine,nadeOrigin,targetOrigin,DONT_IGNORE_MONSTERS,ent,tr);
			nadeOrigin[2] -= 2.0;

			get_tr2(tr,TR_flFraction,fraction);
			if(fraction != 1.0 && get_tr2(tr,TR_pHit) != target) continue;
		}

		// damaged
		if(maxdamage > 0.0)
		{
			damage = radius_calc(distance,FROST_RADIUS,maxdamage,mindamage);
			if(ta) damage /= 2.0; // half damage for friendlyfire
			if(target) damage /= 4.0; // half damage for friendlyfire

			if(damage > 0.0)
			{
				frostKilled[target] = 1;
				ExecuteHamB(Ham_TakeDamage,target,ent,owner,damage,DMG_GRENADE);
				if(!is_user_alive(target)) continue; // dead now
				frostKilled[target] = 0;
			}
		}

		// frozen
		if((by_radius && radius_calc(distance,FROST_RADIUS,100.0,0.0) >= by_radius)
		|| (!by_radius && random_num(1,100) <= floatround(radius_calc(distance,FROST_RADIUS,freeze_maxchance,freeze_minchance))))
		{
			if(freeze_player(target,owner,nadeTeam))
			{
				gotFrozen = 1;
				emit_sound(target,CHAN_ITEM,SOUND_FROZEN,1.0,ATTN_NONE,0,PITCH_LOW);
			}
		}
		
		// chilled
		if(by_radius || random_num(1,100) <= floatround(radius_calc(distance,FROST_RADIUS,chill_maxchance,chill_minchance)))
		{
			if(chill_player(target,owner,nadeTeam))
			{
				if(!gotFrozen) emit_sound(target,CHAN_ITEM,SOUND_CHILLED,VOL_NORM,ATTN_NORM,0,PITCH_HIGH);
			}
		}
	}

	free_tr2(tr);
	set_pev(ent,pev_flags,pev(ent,pev_flags)|FL_KILLME);
}

freeze_player(id,attacker,nadeTeam)
{
	//if ( !shModActive() || !gHasColaLoverPower[id] ) return 1;
	
	new fwdRetVal = PLUGIN_CONTINUE;
	ExecuteForward(fnFwdPlayerFrozen, fwdRetVal, id, attacker);
	
	if(fwdRetVal == PLUGIN_HANDLED || fwdRetVal == PLUGIN_HANDLED_MAIN) {
		return 0;
	}

	if(!isFrozen[id]) //&& gHasColaLoverPower[id])
	{
		pev(id,pev_gravity,oldGravity[id]);

		// register our forward only when we need it
		if(!fmFwdPPT)
		{
			fmFwdPPT = register_forward(FM_PlayerPreThink,"fw_playerprethink",0);
		}
	}

	isFrozen[id] = nadeTeam;
	
	set_pev(id,pev_velocity,Float:{0.0,0.0,0.0});
	set_user_chillfreeze_speed(id);
	
	new Float:duration = get_pcvar_float(pcv_freeze_duration), Float:variance = get_pcvar_float(pcv_freeze_variance);
	duration += random_float(-variance,variance);

	remove_task(TASK_REMOVE_FREEZE+id);
	set_task(duration,"task_remove_freeze",TASK_REMOVE_FREEZE+id);
	
	if(!pev_valid(novaDisplay[id])) { //&& gHasColaLoverPower[id] 
		create_nova(id);
	}
	
	if(get_pcvar_num(pcv_icon) == ICON_ISCHILLED) { //&& gHasColaLoverPower[id]
		show_icon(id, STATUS_FLASH);
	}
	
	return 1;
}

public task_remove_freeze(taskid)
{
	new id = taskid-TASK_REMOVE_FREEZE;
	
	if(pev_valid(novaDisplay[id])) {
		new Float:origin[3];
		pev(novaDisplay[id],pev_origin,origin);

		// add some tracers
		message_begin_fl(MSG_PVS,SVC_TEMPENTITY,origin,0);
		write_byte(TE_IMPLOSION);
		write_coord_fl(origin[0]); // x
		write_coord_fl(origin[1]); // y
		write_coord_fl(origin[2] + 8.0); // z
		write_byte(64); // radius
		write_byte(10); // count
		write_byte(3); // duration
		message_end();

		// add some sparks
		message_begin_fl(MSG_PVS,SVC_TEMPENTITY,origin,0);
		write_byte(TE_SPARKS);
		write_coord_fl(origin[0]); // x
		write_coord_fl(origin[1]); // y
		write_coord_fl(origin[2]); // z
		message_end();

		// add the shatter
		message_begin_fl(MSG_PAS,SVC_TEMPENTITY,origin,0);
		write_byte(TE_BREAKMODEL);
		write_coord_fl(origin[0]); // x
		write_coord_fl(origin[1]); // y
		write_coord_fl(origin[2] + 24.0); // z
		write_coord_fl(16.0); // size x
		write_coord_fl(16.0); // size y
		write_coord_fl(16.0); // size z
		write_coord(random_num(-50,50)); // velocity x
		write_coord(random_num(-50,50)); // velocity y
		write_coord_fl(25.0); // velocity z
		write_byte(10); // random velocity
		write_short(glassGibs); // model
		write_byte(10); // count
		write_byte(25); // life
		write_byte(BREAK_GLASS); // flags
		message_end();

		emit_sound(novaDisplay[id],CHAN_ITEM,SOUND_UNFROZEN,VOL_NORM,ATTN_NORM,0,PITCH_LOW);
		set_pev(novaDisplay[id],pev_flags,pev(novaDisplay[id],pev_flags)|FL_KILLME);
	}

	isFrozen[id] = 0;
	novaDisplay[id] = 0;
	
	// unregister forward if we are no longer using it
	unregister_prethink();

	if(!is_user_connected(id)) return;
	
	// restore speed, but then check for chilled
	ExecuteHam(Ham_Player_ResetMaxSpeed, id);
	set_user_chillfreeze_speed(id);

	set_pev(id,pev_gravity,oldGravity[id]);
	
	new status = STATUS_HIDE;
	
	// sometimes trail fades during freeze, reapply
	if(isChilled[id]) {
		status = STATUS_SHOW;
		
		new rgb[3];
		get_rgb_colors(isChilled[id],rgb);
		set_beamfollow(id,30,8,rgb,100);
	}
	
	if(get_pcvar_num(pcv_icon) == ICON_ISCHILLED) {
		show_icon(id, status);
	}
}

chill_player(id,attacker,nadeTeam)
{
	//if ( !shModActive() || !gHasColaLoverPower[id] ) return 1;
	
	new fwdRetVal = PLUGIN_CONTINUE;
	ExecuteForward(fnFwdPlayerChilled, fwdRetVal, id, attacker);
	
	if(fwdRetVal == PLUGIN_HANDLED || fwdRetVal == PLUGIN_HANDLED_MAIN)
	{
		return 0;
	}

	// we aren't already been chilled
	if(!isChilled[id]) // && gHasColaLoverPower[id]
	{
		oldRenderFx[id] = pev(id,pev_renderfx);
		pev(id,pev_rendercolor,oldRenderColor[id]);
		oldRenderMode[id] = pev(id,pev_rendermode);
		pev(id,pev_renderamt,oldRenderAmt[id]);

		isChilled[id] = nadeTeam; // fix -- thanks Exolent

		// register our forward only when we need it
		//if(!fmFwdPPT) fmFwdPPT = register_forward(FM_PlayerPreThink,"fw_playerprethink",0);
	}

	isChilled[id] = nadeTeam;
	
	set_user_chillfreeze_speed(id);
	
	new Float:duration = get_pcvar_float(pcv_chill_duration), Float:variance = get_pcvar_float(pcv_chill_variance);
	duration += random_float(-variance,variance);

	remove_task(TASK_REMOVE_CHILL+id);
	set_task(duration,"task_remove_chill",TASK_REMOVE_CHILL+id);

	new rgb[3];
	get_rgb_colors(nadeTeam,rgb);
	
	IVecFVec(rgb, glowColor[id]);
	
	// glowshell
	set_user_rendering(id, kRenderFxGlowShell, rgb[0], rgb[1], rgb[2], kRenderNormal, floatround(GLOW_AMOUNT));

	//if (gHasColaLoverPower[id]) { //}
	set_beamfollow(id,30,8,rgb,100);
	
	// I decided to let the frostnade tint override a flashbang,
	// because if you are frozen, then you have much bigger problems.

	// add a blue tint to their screen
	message_begin(MSG_ONE,gmsgScreenFade,_,id);
	write_short(floatround(4096.0 * duration)); // duration
	write_short(floatround(3072.0 * duration)); // hold time (4096.0 * 0.75)
	write_short(FFADE_IN); // flags
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	write_byte(100); // alpha
	message_end();
	
	if(get_pcvar_num(pcv_icon) == ICON_ISCHILLED && !isFrozen[id]) { // && gHasColaLoverPower[id]
		show_icon(id, STATUS_SHOW);
	}
	
	return 1;
}

public task_remove_chill(taskid)
{
	new id = taskid-TASK_REMOVE_CHILL;

	isChilled[id] = 0;
	
	// unregister forward if we are no longer using it
	//unregister_prethink();

	if(!is_user_connected(id)) return;
	
	// set speed to normal, then check for frozen
	ExecuteHam(Ham_Player_ResetMaxSpeed, id);
	set_user_chillfreeze_speed(id);

	// reset rendering
	set_user_rendering(id, oldRenderFx[id], floatround(oldRenderColor[id][0]), floatround(oldRenderColor[id][1]),
		floatround(oldRenderColor[id][2]), oldRenderMode[id], floatround(oldRenderAmt[id]));

	clear_beamfollow(id);

	// calculate end of flashbang
	new Float:flashedUntil = get_pdata_float(id,m_flFlashedUntil),
			Float:flashHoldTime = get_pdata_float(id,m_flFlashHoldTime),
			Float:endOfFlash = flashedUntil + (flashHoldTime * 0.67);
	
	// not blinded
	if(get_gametime() >= endOfFlash)
	{
		// clear tint
		message_begin(MSG_ONE,gmsgScreenFade,_,id);
		write_short(0); // duration
		write_short(0); // hold time
		write_short(FFADE_IN); // flags
		write_byte(0); // red
		write_byte(0); // green
		write_byte(0); // blue
		write_byte(255); // alpha
		message_end();
	}
	
	if(get_pcvar_num(pcv_icon) == ICON_ISCHILLED && !isFrozen[id])
	{
		show_icon(id, STATUS_HIDE);
	}
}

// make a frost nova at a player's feet
create_nova(id)
{
	//if ( !shModActive() || !gHasColaLoverPower[id] ) return
	
	new nova = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"info_target"));

	engfunc(EngFunc_SetSize,nova,Float:{-8.0,-8.0,-4.0},Float:{8.0,8.0,4.0});
	engfunc(EngFunc_SetModel,nova,MODEL_FROZEN);

	// random orientation
	new Float:angles[3];
	angles[1] = random_float(0.0,360.0);
	set_pev(nova,pev_angles,angles);

	// put it at their feet
	new Float:novaOrigin[3];
	pev(id,pev_origin,novaOrigin);
	engfunc(EngFunc_SetOrigin,nova,novaOrigin);

	// make it translucent
	new rgb[3];
	get_rgb_colors(isFrozen[id], rgb);
	IVecFVec(rgb, angles); // let's just use angles

	set_pev(nova,pev_rendercolor,angles); // see above
	set_pev(nova,pev_rendermode,kRenderTransAlpha);
	set_pev(nova,pev_renderfx,kRenderFxGlowShell);
	set_pev(nova,pev_renderamt,128.0);

	drop_to_floor(nova)
	
	novaDisplay[id] = nova;
}

/****************************************
* UTILITY FUNCTIONS
****************************************/

// check if prethink is still being used, if not, unhook it
unregister_prethink()
{
	if(fmFwdPPT)
	{
		new i;
		for(i=1;i<=maxPlayers;i++) if(/*isChilled[i] ||*/ isFrozen[i]) break;
		if(i > maxPlayers)
		{
			unregister_forward(FM_PlayerPreThink,fmFwdPPT,0);
			fmFwdPPT = 0;
		}
	}
}

// make the explosion effects
create_blast(team,Float:origin[3])
{
	new rgb[3];
	get_rgb_colors(team,rgb);

	// smallest ring
	message_begin_fl(MSG_PVS,SVC_TEMPENTITY,origin,0);
	write_byte(TE_BEAMCYLINDER);
	write_coord_fl(origin[0]); // x
	write_coord_fl(origin[1]); // y
	write_coord_fl(origin[2]); // z
	write_coord_fl(origin[0]); // x axis
	write_coord_fl(origin[1]); // y axis
	write_coord_fl(origin[2] + 385.0); // z axis
	write_short(exploSpr); // sprite
	write_byte(0); // start frame
	write_byte(0); // framerate
	write_byte(4); // life
	write_byte(60); // width
	write_byte(0); // noise
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	write_byte(100); // brightness
	write_byte(0); // speed
	message_end();

	// medium ring
	message_begin_fl(MSG_PVS,SVC_TEMPENTITY,origin,0);
	write_byte(TE_BEAMCYLINDER);
	write_coord_fl(origin[0]); // x
	write_coord_fl(origin[1]); // y
	write_coord_fl(origin[2]); // z
	write_coord_fl(origin[0]); // x axis
	write_coord_fl(origin[1]); // y axis
	write_coord_fl(origin[2] + 470.0); // z axis
	write_short(exploSpr); // sprite
	write_byte(0); // start frame
	write_byte(0); // framerate
	write_byte(4); // life
	write_byte(60); // width
	write_byte(0); // noise
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	write_byte(100); // brightness
	write_byte(0); // speed
	message_end();

	// largest ring
	message_begin_fl(MSG_PVS,SVC_TEMPENTITY,origin,0);
	write_byte(TE_BEAMCYLINDER);
	write_coord_fl(origin[0]); // x
	write_coord_fl(origin[1]); // y
	write_coord_fl(origin[2]); // z
	write_coord_fl(origin[0]); // x axis
	write_coord_fl(origin[1]); // y axis
	write_coord_fl(origin[2] + 555.0); // z axis
	write_short(exploSpr); // sprite
	write_byte(0); // start frame
	write_byte(0); // framerate
	write_byte(4); // life
	write_byte(60); // width
	write_byte(0); // noise
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	write_byte(100); // brightness
	write_byte(0); // speed
	message_end();

	// light effect
	message_begin_fl(MSG_PAS,SVC_TEMPENTITY,origin,0);
	write_byte(TE_DLIGHT);
	write_coord_fl(origin[0]); // x
	write_coord_fl(origin[1]); // y
	write_coord_fl(origin[2]); // z
	write_byte(floatround(FROST_RADIUS/5.0)); // radius
	write_byte(rgb[0]); // r
	write_byte(rgb[1]); // g
	write_byte(rgb[2]); // b
	write_byte(8); // life
	write_byte(60); // decay rate
	message_end();
}

// give an entity a beam trail
set_beamfollow(ent,life,width,rgb[3],brightness)
{
	clear_beamfollow(ent);

	message_begin(MSG_BROADCAST,SVC_TEMPENTITY);
	write_byte(TE_BEAMFOLLOW);
	write_short(ent); // entity
	write_short(trailSpr); // sprite
	write_byte(life); // life
	write_byte(width); // width
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	write_byte(brightness); // brightness
	message_end();
}

// removes beam trails from an entity
clear_beamfollow(ent)
{
	message_begin(MSG_BROADCAST,SVC_TEMPENTITY);
	write_byte(TE_KILLBEAM);
	write_short(ent); // entity
	message_end();
}

// gets the appropriate color and displays the frostnade icon to the player with the given status
show_icon(id, status)
{
	if ( !shModActive() || !gHasColaLoverPower[id] ) return
	
	static rgb[3];
	if(status) get_rgb_colors(_:cs_get_user_team(id), rgb); // only get colors if we need to
	
	message_begin(MSG_ONE,gmsgStatusIcon,_,id);
	write_byte(status); // status (0=hide, 1=show, 2=flash)
	write_string("dmg_cold"); // sprite name
	write_byte(rgb[0]); // red
	write_byte(rgb[1]); // green
	write_byte(rgb[2]); // blue
	message_end();
}

// checks if a weapon id is included in fn_nadetypes
is_wid_in_nadetypes(wid)
{
	new types = get_pcvar_num(pcv_nadetypes);
	
	return ( (wid == CSW_HEGRENADE && (types & NT_HEGRENADE))
		|| (wid == CSW_FLASHBANG && (types & NT_FLASHBANG))
		|| (wid == CSW_SMOKEGRENADE && (types & NT_SMOKEGRENADE)) );
}

// checks if a player has a frostnade, taking into account fn_override and such.
// returns: STATUS_HIDE = no frostnade, STATUS_SHOW = has frostnade but not deployed, STATUS_FLASH = has frostnade and deployed
player_has_frostnade(id)
{
	new retVal = STATUS_HIDE, curwpn = get_user_weapon(id);
	
	// no override, variable explicitly set
	if(hasFrostNade[id]) { //&& gHasColaLoverPower[id] 
		retVal = (curwpn == hasFrostNade[id] ? STATUS_FLASH : STATUS_SHOW);
	}
	
	// override enabled, and I'm on the right team
	//else if (gHasColaLoverPower[id]) { //}
	if (get_pcvar_num(pcv_override) && (get_pcvar_num(pcv_teams) & _:cs_get_user_team(id))) {		
		
		new types = get_pcvar_num(pcv_nadetypes);
					
		if((types & NT_HEGRENADE) && cs_get_user_bpammo(id, CSW_HEGRENADE) > 0) {
			retVal = (curwpn == CSW_HEGRENADE ? STATUS_FLASH : STATUS_SHOW);
		}
		
		if(retVal != STATUS_FLASH && (types & NT_FLASHBANG) && cs_get_user_bpammo(id, CSW_FLASHBANG) > 0) {
			retVal = (curwpn == CSW_FLASHBANG ? STATUS_FLASH : STATUS_SHOW);
		}
		
		if(retVal != STATUS_FLASH && (types & NT_SMOKEGRENADE) && cs_get_user_bpammo(id, NT_SMOKEGRENADE) > 0) {
			retVal = (curwpn == NT_SMOKEGRENADE ? STATUS_FLASH : STATUS_SHOW);
		}
	}
	
	return retVal;
}

// gets RGB colors from the cvar
get_rgb_colors(team,rgb[3]) 
{
	static color[12], parts[3][4];
	get_pcvar_string(pcv_color,color,11);
	
	// if cvar is set to "team", use colors based on the given team
	if(equali(color,"team",4))   //  62 34 0 ; los originales son red 150 0 0 y blue 0 0 150
	{
		if(team == 1)
		{
			rgb[0] = 62;
			rgb[1] = 34;
			rgb[2] = 0;
		}
		else
		{
			rgb[0] = 62;
			rgb[1] = 34;
			rgb[2] = 0;
		}
	}
	else
	{
		parse(color,parts[0],3,parts[1],3,parts[2],3);
		rgb[0] = str_to_num(parts[0]);
		rgb[1] = str_to_num(parts[1]);
		rgb[2] = str_to_num(parts[2]);
	}
}

// scale a value equally (inversely?) with the distance that something
// is from the center of another thing. that makes pretty much no sense,
// so basically, the closer we are to the center of a ring, the higher
// our value gets.
//
// EXAMPLE: distance = 60.0, radius = 240.0, maxVal = 100.0, minVal = 20.0
// we are 0.75 (1.0-(60.0/240.0)) of the way to the radius, so scaled with our
// values, it comes out to 80.0 (20.0 + (0.75 * (100.0 - 20.0)))
Float:radius_calc(Float:distance,Float:radius,Float:maxVal,Float:minVal)
{
	if(maxVal <= 0.0) return 0.0;
	if(minVal >= maxVal) return minVal;
	return minVal + ((1.0 - (distance / radius)) * (maxVal - minVal));
}

// sets a user's chilled/frozen speed if applicable
// (NOTE: does NOT reset his maxspeed if he is not chilled/frozen)
set_user_chillfreeze_speed(id)
{
	//if ( !shModActive() || !gHasColaLoverPower[id] ) return
	
	if(isFrozen[id])
	{
		set_user_maxspeed(id, 1.0);
	}
	else if(isChilled[id])
	{
		set_user_maxspeed(id, get_default_maxspeed(id)*(get_pcvar_float(pcv_chill_speed)/100.0));
	}
}

// gets the maxspeed a user should have, given his current weapon
stock Float:get_default_maxspeed(id)
{	
	new wEnt = get_pdata_cbase(id, m_pActiveItem), Float:result = 250.0;

	if(pev_valid(wEnt))
	{
		ExecuteHam(Ham_CS_Item_GetMaxSpeed, wEnt, result);
	}
	
	return result;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang3082\\ f0\\ fs16 \n\\ par }
*/
